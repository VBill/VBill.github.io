<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>流水账-ASC15超级计算机竞赛与近期总结</title>
    <url>/2015/04/04/ASC15/</url>
    <content><![CDATA[<p>记个流水账，就当是日记，并非总结技术。</p>
<p>假期一直到3月中下旬一直都在弄并行计算方面的事情。虽然之前和班上同学一起打算水一水信息安全竞赛（他们打算做安卓方向，但都没有基础，正好我上过学校开的安卓课程，可以帮帮他们），而且假期有那么一周确实埋头做了很多事，但是最后大家都水过去了（我是在看并行计算的东西，其他人在我研究完Xposed框加后就啥都没往下弄了）。结果可想而知，开学要选指导老师，我们因为没有成品，而且老师问了几个很切中要害的问题（大二有没有时间做这个，学习成绩怎么样，做项目有过需求调查没有，点子有人做过没），于是大家就放弃了。</p>
<p>ASC15超级计算机竞赛听起来很不错，但是我们参赛学生并没有获得很多学院和学校的支持，因为这个竞赛才举办几届。去年寒假我就听说了有这个竞赛。本来想去，但是当时还是太听话，遵循学校的规定第一学期不带电脑，所以C和C++靠的是C4Droid学的。这样的水平当然不会贸然参赛。现在想来遵循校规实在毫无必要，因为我平时不用电脑来打游戏，不带电脑也只是怕辅导员查而已（其实若被查到编程什么事都不会有）。若是当时带了电脑，现在不知道技术水平会是什么样。有的时候就是应该<strong><em>做自己想做的事，不去考虑别人想让你做什么</em></strong>。</p>
<p>今年感觉基础可以了，偶然机会找到了校竞赛的群，加了进去找老师报了名。当时离期末停课还有一个月，感觉还来得及准备。以前折腾过一段时间Linux，写程序基本上C++多，所以看并行计算的东西没什么问题。当时让我负责的是MPI这部分（真是太看得起我了，不进决赛根本用不到MPI的）。也许以后有时间我会总结MPI和OpenMP编程。</p>
<p>假期搞了一周的Xposed框架，然后大部分时间看并行计算。主办方在北京弄了一个2天的培训，我和另外三个小伙伴自费过去听的。题目拿到了以后第一件事就是搜索串改并那题的背景，第一天居然就翻到了论文！春节那几天还是偷了点懒，开小差去弄QT去了。</p>
<p>假期期间整个团队的效率其实很低的，开学后发现大家基本都对题目没啥进展。不过经过讨论还是有些眉目的。不得不承认我们的组织还是有问题，应该多找人参加，制定学习计划。本来6个人的团队，参加开学讨论的只有4个人了，而且除了我另外三位第一年都参加过比赛（比赛要求5人，最后几天我们又找来了一个人）。另外，老师也没申请到学校的设备，所以只能ssh到主办方提供的远程平台上测试。不过大家只管干！而且留下来的人确实都挺厉害：带队的是学校里非常活跃的技术牛人，一起和我做串改并的是校ACM队员，还有一位貌似非常熟悉计算机硬件体系，我自己好歹第一年也拿了个国奖：）。所以说能坚持做一件事的人必有过人之处。</p>
<p>一直到初赛截止前，大家都在忙。截止的前一天晚上，我们把英文的方案提交了上去。</p>
<p>然后等待结果出来，发现是第18名，可是只有16支队能进决赛。。。<a href="http://www.asc-events.org/ASC15/index15.php">http://www.asc-events.org/ASC15/index15.php</a></p>
<p>老师对这个结果还算满意，因为比赛的条件并不好。听队友说去年只是临近截止3天前才开始干，只弄了三天就交上去了，当时还都是大一。准备写文档时我看了去年的方案，发现串改并只有9倍多的加速。然而今年的结果是51倍的加速，进步很大。老师向主办方问了，大概也是后面串改并做的好，前面搭建超算平台的设计方案失分多（因为大家没设备，只是简单分析了一下）。</p>
<p>总的来说我们都尽力了，只能来年再战了！</p>
<p>尽管没进决赛，我还是学到了挺多东西。我觉得一个团队要做成一件事情必须要有凝聚力，不管发生什么情况都不会散才行。这凝聚力的来源就是大家对这件事本身的热情。如果团队中的人把这件事当成自己的很重要的事去做，而不是只想水过去，那么即使条件很不好，也可以把事情做得很精彩。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对于C++的差异对比</title>
    <url>/2015/09/09/C-andJava/</url>
    <content><![CDATA[<p>开学这几天读Thinking in Java（新学期教材），正好顺便总结Java相对于C++的一些差异。太明显的语言差异就不写了（比如所有东西都放在类里，没有全局变量之类的）。另外，这不是一个总结Java或C++特性的文章，所以两者当中很多各自独有的特性是没有总结的。，</p>
<h2 id="语言特性"># 语言特性</h2>
<ul>
<li>java没有运算符重载。</li>
<li>没有goto</li>
<li>可以break和continue到某个标签。但是标签后不能跟语句。常用来中断多层循环。</li>
<li>增加for each循环</li>
<li>没有const关键字，final表示不可更改的量（对基本类型可看作常量，对对象而言则是引用不能指向其他对象，但被指对象是可以修改的）。</li>
<li>if、for、while等的判断条件中必须使用boolean类型，类似<code>while(1)</code>之类的是不允许的。</li>
</ul>
<h2 id="基本数据类型和变量"># 基本数据类型和变量</h2>
<ul>
<li>Java的char是16位，8位的是byte</li>
<li>没有无符号类型</li>
<li>short、int、liong分别是16、32、64位</li>
<li>内部大括号变量名不能覆盖外面同名变量。所以内层大括号不能有和外层变量同名的变量。</li>
<li>非基本类型的比较用equals()方法。小心String，Integer这些。</li>
<li>boolean型不能被转化为其它类型。</li>
<li>数组声明时不能指定大小（类似<code>int a[100];</code>是不可行的），必须在声明后new出对象时给出new对象的个数，从而给出数组大小（<code>int a[]=new int[100];</code>）。</li>
<li>java的数组是一个对象，它持有某种特定类的引用。直接<code>new 对象[n]</code>得到的是一个内置n个null引用的对象，若是基本类型则自动为0，多维数组同理。c++相同代码将自动调用无参数的构造函数生成对象。</li>
<li>多维数组中同一维上的各个数组可以不等长。C++必须利用指针数组和动态内存分配实现不等长数组。</li>
</ul>
<h2 id="运算符"># 运算符</h2>
<ul>
<li>增加无符号右移操作&gt;&gt;&gt;和&gt;&gt;&gt;=，高位补0.</li>
<li>没有sizeof()，因为无论什么平台，java的数据类型长度都是一样的。</li>
<li>不能在赋值语句里用连续的逗号（如：a=1,2,3;）。而且不能用逗号分开语句。</li>
</ul>
<h2 id="对象初始化和清除"># 对象初始化和清除</h2>
<ul>
<li>不支持构造函数的初始化列表（但是可以把类内部对象的初始化代码看作初始化列表）。</li>
<li>Java自己的构造方法调用自身其他构造方法必须以：<code>this(参数列表);</code> 的方式调用，且必须在构造方法开始处。C++只需：<code>new (this)类名(参数列表);</code> 就可以调用，且位置随意。</li>
<li>静态方法调用是：类名.方法， 而C++则是：类名::方法。</li>
<li>Java类内有static代码块。里面内容只执行1次，在该类第一个对象生成或首次访问其静态成员时执行。</li>
<li>java类内非static代码快在对象被new出来时执行，C++类内部不能写代码。所以java非static代码块可在任意处。</li>
<li>java的static成员在类内直接指定初始化值，C++的static成员在类外和main外的全局区域（类型名 类名::static成员名=xxx）。</li>
<li>java的方法内不能有静态变量（和内存布局有关，静态变量在data区，而方法内的属于栈区，只能存放基本类型和引用，见<a href="http://bbs.itheima.com/thread-31083-1-1.html">链接</a>）</li>
<li>java可以在类的定义里为变量赋初值，C++不行。</li>
<li>Java会把类定义里变量赋初值工作放在类的代码最前面（在构造方法调用前就执行）。且初始化顺序和定义顺序相同。</li>
</ul>
<h2 id="类特性"># 类特性</h2>
<ul>
<li>增加反射机制</li>
<li>没有多重继承（但可以实现多个接口类，或者用多个内部类替代）</li>
<li>Java的内部类定义位置随意，C++的必须把内部类定义放在使用内部类之前的地方。</li>
<li>java的static成员只能new被static修饰的内部类，C++没有static内部类，static方法可以直接new内部类。</li>
<li>C++内部类不能直接访问外部类的成员。但java可以。</li>
<li>没有友元</li>
<li>只有公共继承（extends关键字）</li>
<li>基类方法被重载后，如果在子类中重新定义这个方法不会屏蔽任何一个在基类中的版本。</li>
<li>java类内的protected成员可以被同一个包内的类访问。C++类的protected成员不能被一个名字空间的类访问。所以名字空间=包的想法是不对的。</li>
<li>增加final关键字阻止覆盖方法。被指定为final的类型不能被继承。</li>
<li>重写方法自动是动态绑定的，不像C++需要virtual关键字。</li>
<li>java向下转型会检查对象实际是不是被转到的类型。C++不检查。</li>
<li>增加abstract关键字，修饰方法（等价于C++纯虚函数），修饰类（这种类含有abstract方法，等价于C++抽象类）。</li>
<li>增加接口（Interface），但是接口无构造方法，接口内方法自动为public，且内部变量自动为static。C++纯虚类可以有构造方法，非静态成员等等。</li>
</ul>
<h2 id="异常处理"># 异常处理</h2>
<ul>
<li>C++没有finally关键字</li>
<li>C++可以throw和函数的异常说明列表不同的异常，java则必须抛出和异常说明表相同的异常。</li>
<li>两者都可以在main里抛出异常，但C++的main不能有throw列表。</li>
</ul>
<h2 id="泛型"># 泛型</h2>
<ul>
<li>java的泛型参数类型不能为基本类型。</li>
<li>定义java的泛型函数（方法）的泛型参数列表要放在返回值之前。C++需要用<code>template&lt;class T&gt;</code></li>
<li>对函数（方法）显示地进行类型说明时：java在 . 操作符和方法之间插入尖括号说明（类内部用this.），C++是在方法名和参数列表之间放尖括号。</li>
<li>java的父类容器存放子类，可以从容器中取出对象调用子类方法，C++的STL容器中始终调用父类方法（甚至用虚函数也是）。</li>
<li>Java在泛型代码内部无法获得任何有关泛型参数的类型信息。</li>
<li>Java中，若泛型参数为T，不能new T()。原因见上一条。</li>
<li>java中增加了C++没有的通配符‘?’（注意? super 和? extends的用法）。</li>
</ul>
<h2 id="其它"># 其它</h2>
<ul>
<li>java的String是不可变的，C++的string可变。</li>
</ul>
<p>以上只是初步的总结，如果总结的有问题请留下评论。大概以后还会更新这篇文章。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeblocks下配置C++11</title>
    <url>/2014/05/17/Codeblocks-cpp11/</url>
    <content><![CDATA[<p>1.下载MINGW4.9。先从网站<a href="http://www.mingw.org/">http://www.mingw.org/</a>上下载在线安装器（页面右边有DOWNLOAD INSTALLER按钮）。</p>
<p>2.我是WIN7的64位机子，选择下面这种配置：（如果不用POSIX而选WIN32反而用不了）</p>
<figure>
<img src="/img/codeblocks_cpp11/1.png" alt="" /><figcaption>pic1</figcaption>
</figure>
<p>3.装好后配置CODEBLOCKS：</p>
<figure>
<img src="/img/codeblocks_cpp11/2.png" alt="" /><figcaption>pic2</figcaption>
</figure>
<figure>
<img src="/img/codeblocks_cpp11/3.png" alt="" /><figcaption>pic3</figcaption>
</figure>
<p>4.写个程序运行一下：</p>
<pre><code>    #include &lt;thread&gt;
    #include &lt;iostream&gt;
    using namespace std;
    void hello()
    &#123;
        cout&lt;&lt;&quot;Hello from thread&quot;&lt;&lt;endl;
    &#125;
    
    int main()
    &#123;
        thread t1(hello);
        t1.join();
        cout&lt;&lt;&quot;Main Thread&quot;&lt;&lt;endl;
        return 0;
    &#125;
    </code></pre>
<figure>
<img src="/img/codeblocks_cpp11/4.png" alt="" /><figcaption>pic4</figcaption>
</figure>
]]></content>
      <categories>
        <category>开发环境配置</category>
      </categories>
      <tags>
        <tag>开发环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>About my blog</title>
    <url>/2015/01/01/First-hexo-article/</url>
    <content><![CDATA[<p>一直想搭建一个真正意义上自己的博客。之前在CSDN上面有博客，但是写的不勤。我觉得博客应该坚持写，把自己学到的知识总结好。其实写文章的过程是回顾自己所学的一个很好的途径。之前在CSDN上想写，但是总是以“ 这学期很忙” 来敷衍自己。我想博客如果是自己搭建的而不仅仅只是注册在某个网上的空间，也许就会认真对待些吧。所以就想到弄个个人的博客站点，顺便再把以前的文章搬运过来。本来说考完期末再弄，但是今天图书馆关门，晚上教学楼太冷，就回寝室自习了。结果在寝室里做题错误率爆涨，只好找点别的事做。大概也就这个事情不太耗费脑力了。正好新年开个头，弄个博客，希望今年自己在技术上多进步些吧。</p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy多进程的 KNN 手写识别器</title>
    <url>/2015/08/04/KNN-digit-recognizer/</url>
    <content><![CDATA[<p>头一次在Kaggle上做比赛。网上说从101类型的开始，都是教学类型的比赛，于是就找了一个好做的做做先。</p>
<p>不知道为什么，Numpy不能自动并行矩阵运算。然后python的多线程不能同时在多核环境上跑。所以写了一个多进程的版本。</p>
<p>放代码：</p>
<pre><code>import multiprocessing
import csv
from numpy import*

def readTrainFile():
    m=[]
    with open(&#39;train.csv&#39;, &#39;rb&#39;) as trainer:
        rawfile=csv.reader(trainer)
        for row in rawfile:
            m.append(row)
    m.remove(m[0])
    for row in m:
        row[0]=int(row[0])
        for i in xrange(1,size(row)):
            if(row[i]!=&#39;0&#39;):
                row[i]=1
            else:
                row[i]=0
    return mat(m)
    
def readTestFile():
    m=[]
    with open(&#39;test.csv&#39;, &#39;rb&#39;) as tester:
        rawfile=csv.reader(tester)
        for row in rawfile:
            m.append(row)
    m.remove(m[0])
    for row in m:
        for i in xrange(size(row)):
            if(row[i]!=&#39;0&#39;):
                row[i]=1
            else:
                row[i]=0
    return mat(m)
    
def worker(trainMat, unknownMat, k, cpu_id, pipe):
    trainSize=trainMat.shape[0]
    unknownSize=unknownMat.shape[0]
    
    comMat=mat(zeros((trainSize, trainMat.shape[1]-1)))
    sample=mat(zeros((trainSize, trainMat.shape[1]-1)))
    sorter=mat(zeros((trainSize,2)))
    sortedId=zeros((trainSize,1)) 
    result=[]
    voter=zeros((10,1))
    
    for no in xrange(unknownSize):
        voter=zeros((10,1))
        sample=unknownMat[no,:]
        comMat=tile(sample, (trainSize,1)) - trainMat[:,1:]
        comMat=mat(array(comMat)**2)
        sorter[:,0]=trainMat[:,0]
        sorter[:,1]=comMat.sum(axis=1)
        sortedId=sorter[:,1].argsort(axis=0)
        for i in xrange(k):
            vote=int(sorter[:,0][sortedId[i]])
            voter[vote]=voter[vote]+1
        result.append(voter.argmax())
        print &quot;This is &quot;,no,&quot; th sample in CPU No.&quot;, cpu_id
    pipe.send(array(result))

def saveRes(result):
    with open(&#39;res.csv&#39;, &#39;wb&#39;) as resFile:
        writer=csv.writer(resFile)
        writer.writerow([&#39;ImageId&#39;, &#39;Label&#39;])
        r=zeros((result.shape[0],2))
        r[:,0]=array(range(1,result.size+1))
        r[:,1]=result
        for i in r.tolist():
            i[0]=int(i[0])
            i[1]=int(i[1])
            writer.writerow(i)

def collector(r_pipe, pipes):
    res=[]
    for p in pipes:
        res.extend(p.recv().tolist())
    res=array(res)
    r_pipe.send(res)

if __name__ == &quot;__main__&quot;:
    train_set=readTrainFile()
    test_set=readTestFile()
    k=1
    print &quot;Read file ok! k= &quot;,k
    
    cpu_n=multiprocessing.cpu_count()
    b_size=test_set.shape[0]/cpu_n
    process=[]
    pipes=[]
    print b_size, cpu_n
    for i in xrange(cpu_n):
        pipe=multiprocessing.Pipe()
        p = multiprocessing.Process(target = worker, 
            args = (train_set, test_set[i*b_size:(i+1)*b_size,:], k, i, pipe[0], ))
        process.append(p)
        pipes.append(pipe[1])
        p.start()
    
    pipe=multiprocessing.Pipe()
    r_pipe=pipe[1]
    collect_process=multiprocessing.Process(target = collector, args=(pipe[0], pipes,))
    collect_process.start()
    res=r_pipe.recv()
    saveRes(res)
    
    command=raw_input(&quot;Press a to terminate processes!&quot;)
    if(command==&#39;a&#39;):
        for p in process:
            p.terminate()
            </code></pre>
<p>所有的训练样本用上大概需要跑4个小时。大概占用2.5G内存，并且运行时有500MB的波动（可能python写得太搓了，中间有对象不断生成然后释放，以后还会改这份代码）。比单进程的版本要快3倍。我的电脑是AMD A8的四核笔记本，内存8G。Numpy用的是Ubuntu包管理器里的。会不会用Intel的MKL重新编译一下会好些呢？这个以后也可以尝试一下。这份代码跑出来的准确率是0.96271，这个准确率比较靠后了。不管是k值取1还是3准确率都相同。难道取更大些好？因为KNN算法效率实在太渣，所以不打算继续在这个方法上再做尝试了。也许应该换些别的算法。看见有人把准确率弄到100%，简直丧心病狂。</p>
<p>头一次做kaggle还是挺有收获的，主要体验了一把python的多进程还有实际应用场景。这只是个尝试性的测验，以后还可以再做改进。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>GitIgnore使用</title>
    <url>/2015/02/06/GitIgnore/</url>
    <content><![CDATA[<p>假期和另外几个同学做一个安卓下的安全APP，一起在oschina上建了个私有仓库，用IntelliJ开发。Merge时候有几个文件冲突了。</p>
<p>为了防止提交上去的文件冲突，是一定要在项目的根目录下加上一个名叫”.gitignore”的文件。主要冲突的就是IntelliJ自身的工程配置文件，还有每个人调试程序生成的类以及apk.</p>
<p>主要参考<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a>这里的内容写成。</p>
<pre><code># Built application files
*.apk
*.ap_
# Files for the Dalvik VM
*.dex
# Java class files
*.class
# Generated files
bin/
gen/
# Gradle files
.gradle/
build/
/*/build/
# Local configuration file (sdk path, etc)
local.properties
# Proguard folder generated by Eclipse
proguard/
# Log Files
*.log

# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm
*.iml
## Directory-based project format:
.idea/
# if you remove the above rule, at least ignore the following:
# User-specific stuff:
# .idea/workspace.xml
# .idea/tasks.xml
# .idea/dictionaries
# Sensitive or high-churn files:
# .idea/dataSources.ids
# .idea/dataSources.xml
# .idea/sqlDataSources.xml
# .idea/dynamic.xml
# .idea/uiDesigner.xml
# Gradle:
# .idea/gradle.xml
# .idea/libraries
# Mongo Explorer plugin:
# .idea/mongoSettings.xml
## File-based project format:
*.ipr
*.iws
## Plugin-specific files:
# IntelliJ
out/
# mpeltonen/sbt-idea plugin
.idea_modules/
# JIRA plugin
atlassian-ide-plugin.xml
# Crashlytics plugin (for Android Studio and IntelliJ)
com_crashlytics_export_strings.xml
crashlytics.properties
crashlytics-build.properties</code></pre>
<p>附上<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000">gitignore</a>的小教程</p>
<p>比较全面的gitignore用法：<a href="http://git-scm.com/docs/gitignore">http://git-scm.com/docs/gitignore</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt射击游戏</title>
    <url>/2015/02/28/Qt-shooting-game/</url>
    <content><![CDATA[<p>春节放假到开学前几天学了学Qt。主要是想了解下Linux下开发带图形界面的程序。我是跟着教Google搜索到的教程学的（Qt3），然后又通过查资料和Qt Assistant学了一点Qt creator算是初步入门。</p>
<p>然后离开学一周前写了一个<a href="https://github.com/VBill/Invador_game_qt">射击游戏</a>（美工不行，就随便画几个图形上去代替了）。算是自己写的第一个C++图形界面程序。</p>
<p>代码比较简单，就不详细分析了。主要就是：目标(target)、炮(cannon)、游戏判定区(judgement)、游戏界面（gameboard）这几个类。游戏开始时生成10个目标（原来是15个，后来自己玩了几次发现根本赢不了）。目标会匀速向下移动。目标全清就胜，否则当目标到达炮台高度就算输。</p>
<p>用到的相关知识点：在Qt绘图的一系列函数、Qt自定义快捷键、信号和槽、QTimer使用（控制游戏物理过程）、STL库（不想写数据结构偷懒用的）、Qt creator的使用。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ下开发Xposed模块无法运行</title>
    <url>/2015/02/12/Xposed-IntelliJ/</url>
    <content><![CDATA[<p>昨天按照github上Xposed的官方教程写Xposed模块，但是怎么也运行不起来。后来查log发现报错了。错误是 <code>java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation</code>。</p>
<p>解决方法是：鼠标右键点击工程，选择“Open Module Settings”，在弹出的窗口中打开Dependencies选项卡。把XposedBridgeApi这个jar包后面的Scope属性改成provided。</p>
<p>解决方案<a href="http://stackoverflow.com/questions/15605898/java-lang-illegalaccesserror-class-ref-in-preverified-class-resolved-to-unexpect/18335122#18335122">来源</a>。有一篇文章讲了<a href="http://www.alloyteam.com/2014/04/android-cha-jian-yuan-li-pou-xi/">原理</a>，以后留着看。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>（译）Xposed Helpers</title>
    <url>/2015/02/11/Xposed-helpers/</url>
    <content><![CDATA[<p><a href="https://github.com/rovo89/XposedBridge/wiki/Helpers">原文地址</a>。主要讲解Xposed框架helper类里的各种方法。</p>
<p>Xposed中有许多Helper方法使得模块的开发变得更为简单。</p>
<h2 id="xposedbridge类"># XposedBridge类</h2>
<h2 id="log">log</h2>
<p><code>log</code>方法是一个向标准logcat和<code>/data/xposed/debug.log</code>文件输出错误信息的简单方式。它可以捕获日志信息或者一个<code>Throwable</code>对象。后面的例子中，它将打印堆栈踪迹。</p>
<h2 id="hookallmethods-hookallconstructors">hookAllMethods / hookAllConstructors</h2>
<p>如果你想把所有的方法都以一个指定的名称hook起来，或是hook类中所有的构造函数，你可以使用这两种方法。当有许多不同的变量，可是你希望在它们当中任何一个被调用之前/后都执行一段代码时，这是非常有用的。时刻记住，其它的ROM也许有额外的变量同样也被hook。尤其小心你在回调时得到的<code>args</code>。</p>
<h2 id="xposedhelpers类"># XposedHelpers类</h2>
<p>我建议把这个类添加到Eclipse的<strong>静态导入</strong>的偏好设置中：Window =&gt; Preferences =&gt; Java =&gt; Editor =&gt; Content Assist =&gt; Favorites =&gt; New Type，输入：de.robv.android.xposed.XposedHelpers。这样做的话，eclipse在你开始输入“get…”时会自动提示这个类中的方法，并且会创建这个方法的静态导入（这意味着在你的代码中是看不到类名的）。</p>
<h2 id="findmethod-findconstructor-findfield">findMethod / findConstructor / findField</h2>
<p>有许多你不必亲自使用反射获得方法、构造函数和字段的方式。同样，你也可以对几个特定参数种类使用“最佳匹配”来寻找方法和构造函数。比如：你可以用一个<code>TextView</code>类型的参数来调用<code>findMethodBestMatch(Class&lt;?&gt; clazz, String methodName, Object... args)</code>。如果没有更加符合匹配的变量，这同样会找到一个具有你指定的名称而且以View类型对象作为参数的方法。</p>
<h2 id="callmethod-callstaticmethod-newinstance">callMethod / callStaticMethod / newInstance</h2>
<p>利用上文提到的findXXX方法，这些方法使得调用方法和创建一个类的实例变得简单。调用者不必为此而使用反射。没有必要事先就取得某个方法，只要及时使用以上的这些方法调用它就可以了。参数类型是从实际的参数值和最匹配的被调用方法中自动拷贝而来。万一你想明确的指出参数的类型，创建一个<code>Class&lt;?&gt;</code>数组，然后把它传递给callXXX/newInstance。你可以使数组中的一些项为空（null）来使用实际参数的类型。但是数组的长度必须和参数的个数匹配。</p>
<h2 id="getxxxfield-setxxxfield-getstaticxxxfield-setstaticxxxfield">getXXXField / setXXXField / getStaticXXXField /setStaticXXXField</h2>
<p>它们是让你能够轻易获得和设置对象实例和类变量内容的封装器。你只需要对象的引用、字段名、和类型（当然还有提供给setter的新值）。如果你想获得/设置一个静态字段，并且没有对象的引用，你可以使用<code>getStaticXXX</code>和 <code>setStaticXXX</code>方法。然而当你有一个对象的引用时，区分静态和实例字段是没有必要的。<code>getXXX</code>和<code>setXXX</code>可以给两者都设定值。</p>
<h2 id="getadditionalxxxfield-setadditionalxxxfield">getAdditionalXXXField / setAdditionalXXXField</h2>
<p>这些方法让你将任何值与一个对象的实例或是整个类（像是一个静态字段）联系起来。这些值依照关键字-值对的方式存储。所以每个对象可以存储多个值。关键字可以是任何字符串，包括对象实际拥有的字段的名称。请注意你不能通过调用<code>getAdditionalInstanceField</code>获取你之前用<code>setAdditionalStaticField</code>存储的值。取而代之的是应该使用<code>getAdditionalStaticField</code>。它有一个变量来接受对象并自动查询它的类。</p>
<h2 id="assetasbytearray">assetAsByteArray</h2>
<p>这个方法以byte数组的形式返回资源。如果你想加载你模块的资源，你可以使用以下代码：</p>
<pre><code>public class XposedTweakbox implements IXposedHookZygoteInit &#123;
    @Override
    public void initZygote(StartupParam startupParam) throws Throwable &#123;
        Resources tweakboxRes = XModuleResources.createInstance(startupParam.modulePath, null);
        byte[] crtPatch = assetAsByteArray(tweakboxRes, &quot;crtfix_samsung_d506192d5049a4042fb84c0265edfe42.bsdiff&quot;);
...</code></pre>
<h2 id="getmd5sum">getMD5Sum</h2>
<p>返回文件系统中一个文件的MD5值。当前的app需要获取读这个文件的权限（在<code>init</code>方法中你拥有root权限，所以这应该不是什么问题）。</p>
<h2 id="getprocesspid">getProcessPid</h2>
<p>按照进程的/proc/[pid]/cmdline的第一部分来寻找这个进程，并以字符串形式返回它的PID。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>（译）Xposed-替换资源</title>
    <url>/2015/02/12/Xposed-replacing-resources/</url>
    <content><![CDATA[<p>这是Xposed在github上的最后一篇教程。<a href="https://github.com/rovo89/XposedBridge/wiki/Replacing-resources">原文地址</a></p>
<p>Xposed使得替换资源，比如：图像和字符串之类的事变得容易。下面是做法：</p>
<h2 id="简单的资源"># 简单的资源</h2>
<pre><code>@Override
public void initZygote(IXposedHookZygoteInit.StartupParam startupParam) throws Throwable &#123;
    XResources.setSystemWideReplacement(&quot;android&quot;, &quot;bool&quot;, &quot;config_unplugTurnsOnScreen&quot;, false);
&#125;

@Override
public void handleInitPackageResources(InitPackageResourcesParam resparam) throws Throwable &#123;
    // replacements only for SystemUI
    if (!resparam.packageName.equals(&quot;com.android.systemui&quot;))
        return;

    // different ways to specify the resources to be replaced
    resparam.res.setReplacement(0x7f080083, &quot;YEAH!&quot;); // WLAN toggle text. You should not do this because the id is not fixed. Only for framework resources, you could use android.R.string.something
    resparam.res.setReplacement(&quot;com.android.systemui:string/quickpanel_bluetooth_text&quot;, &quot;WOO!&quot;);
    resparam.res.setReplacement(&quot;com.android.systemui&quot;, &quot;string&quot;, &quot;quickpanel_gps_text&quot;, &quot;HOO!&quot;);
    resparam.res.setReplacement(&quot;com.android.systemui&quot;, &quot;integer&quot;, &quot;config_maxLevelOfSignalStrengthIndicator&quot;, 6);
&#125;</code></pre>
<p>这就是“简单”的替换，通过这种方式你可以直接替换值。这种方式可以用于：Boolean, Color, Integer, int[], String and String[]。</p>
<p>如你所见，有几种不同的设置替换资源的方式。对于构成安卓框架一部分的所有地方都应该被替换的资源（对所有的app都可用），你应在<code>initZygote</code>中调用<code>XResources.setSystemWideReplacement(...)</code>方法。对于特定app的资源，你需要核实过你确实在正确的app之后在<code>hookInitPackageResources</code>中调用<code>res.setReplacement</code>。这时你不应使用<code>setSystemWideReplacement</code>因为可能会产生你无法预料的副作用。</p>
<p>替换Drawable也采用相似的办法。然而你不能只使用Drawable作为替换物，因为这可能导致同一个Drawable实例被不同的ImageViews引用。因此，你需要使用包装器：</p>
<pre><code>resparam.res.setReplacement(&quot;com.android.systemui&quot;, &quot;drawable&quot;, &quot;status_bar_background&quot;, new XResources.DrawableLoader() &#123;
    @Override
    public Drawable newDrawable(XResources res, int id) throws Throwable &#123;
        return new ColorDrawable(Color.WHITE);
    &#125;
&#125;);</code></pre>
<h2 id="复杂资源"># 复杂资源</h2>
<p>更加复杂的资源（比如动画类型的Drawable）必须从你的模块资源当中被引用。我们假设你想要替换电池图标。下面是代码：</p>
<pre><code>package de.robv.android.xposed.mods.coloredcirclebattery;

import android.content.res.XModuleResources;
import de.robv.android.xposed.IXposedHookInitPackageResources;
import de.robv.android.xposed.IXposedHookZygoteInit;
import de.robv.android.xposed.callbacks.XC_InitPackageResources.InitPackageResourcesParam;

public class ColoredCircleBattery implements IXposedHookZygoteInit, IXposedHookInitPackageResources &#123;
    private static String MODULE_PATH = null;

    @Override
    public void initZygote(StartupParam startupParam) throws Throwable &#123;
        MODULE_PATH = startupParam.modulePath;
    &#125;

    @Override
    public void handleInitPackageResources(InitPackageResourcesParam resparam) throws Throwable &#123;
        if (!resparam.packageName.equals(&quot;com.android.systemui&quot;))
            return;

        XModuleResources modRes = XModuleResources.createInstance(MODULE_PATH, resparam.res);
        resparam.res.setReplacement(&quot;com.android.systemui&quot;, &quot;drawable&quot;, &quot;stat_sys_battery&quot;, modRes.fwd(R.drawable.battery_icon));
        resparam.res.setReplacement(&quot;com.android.systemui&quot;, &quot;drawable&quot;, &quot;stat_sys_battery_charge&quot;, modRes.fwd(R.drawable.battery_icon_charge));
    &#125;
&#125;</code></pre>
<blockquote>
<p>你可以随意命名你的替换资源。我选择 batterry_icon 替代 stat_sys_battery 让它们在本文中更好区分。</p>
</blockquote>
<p>之后把 “battery_icon” 和 “battery_icon_charge” 这两个Drawable添加到你的模块当中。最简单的情况是添加 “res/drawables/battery_icon.png” 和 “res/drawables/battery_icon_charge.png”。但是你可以使用Android提供的所有方式来定义资源。所以对于动画图标，你可使用带有<code>animation-list</code>和其它Drawable资源引用的XML文件。当然这个XML文件也必须放在你的模块内。</p>
<p>通过这些替换，你能要求Xposed将所有指向特定资源的请求跳到你自己的模块。这同样意味着你可以利用<a href="http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources">qualifier</a>，比如：如果你对landscape或更低的屏幕密度需要不同的资源。翻译也可以以相同的方式提供。同样，你也许需要这么做如果原来的资源使用qualifier。你不能仅仅替换一段文字的西班牙语版本。正如前面提到的，请求是向前的，所以它会完全被你的模块资源处理，并且不会察觉其它翻译的存在。</p>
<p>这个技巧基本上对所有资源类型都有效。除了极个别的像主题之类的。</p>
<h2 id="修改布局"># 修改布局</h2>
<p>尽管理论上你可以用之前提到的技巧彻底替换布局，但这有很多坏处。你必须从原有布局中复制整个布局，这会降低对其它ROM的兼容性。主题也许回丢失。只有一个模块可以代替布局。如果两个模块都尝试这么做，后者将会胜出。最重要的是，其它资源的ID和引用是很难定义的。因此，我不推荐这样做。</p>
<p>作为一种好的选择，你可以使用后填充的hook。下面是你怎么做：</p>
<pre><code>@Override
public void handleInitPackageResources(InitPackageResourcesParam resparam) throws Throwable &#123;
    if (!resparam.packageName.equals(&quot;com.android.systemui&quot;))
        return;

    resparam.res.hookLayout(&quot;com.android.systemui&quot;, &quot;layout&quot;, &quot;status_bar&quot;, new XC_LayoutInflated() &#123;
        @Override
        public void handleLayoutInflated(LayoutInflatedParam liparam) throws Throwable &#123;
            TextView clock = (TextView) liparam.view.findViewById(
                    liparam.res.getIdentifier(&quot;clock&quot;, &quot;id&quot;, &quot;com.android.systemui&quot;));
            clock.setTextColor(Color.RED);
        &#125;
    &#125;); 
&#125;</code></pre>
<p>每当“status_bar”布局被填充时，回调方法<code>handleLayoutInflated</code>就被调用。在你以参数形式得到的LayoutInflatedParam对象中，你可以找到刚被创建的View并在需要时修改它。你同样会得到<code>resNames</code>用来鉴别这个方法因哪个布局而被调用（万一你对多个布局使用同一种方法），还有<code>variant</code>，比如可能包含<code>layout-land</code>，如果它就是被加载的布局的版本的话。<code>res</code>帮助你以布局从同一个来源得到ID或额外的资源。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>一个快速排序程序</title>
    <url>/2014/05/18/a-qsort-program/</url>
    <content><![CDATA[<p>很讨厌不少教材上排序时两边向中间的扫描的方法，感觉很麻烦。看见《算法导论》上是单向扫描的分区方法，感觉实现起来很简单。这里和《算法导论》上的只有一点不同，基准数选了第一个数（其实没什么区别）。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
using namespace std;

class QSorter&#123;
    vector&lt;int&gt; data;

    void QS(vector&lt;int&gt;&amp;, int, int);
    int Partition(vector&lt;int&gt;&amp;, int, int);
public:
    void QSort_DM();
    void GenNum(int);
    QSorter()&#123; srand(time(NULL)); &#125;
    QSorter(int n)&#123; srand(time(NULL)); GenNum(n); &#125;
    void OutData();
&#125;;

void QSorter::OutData()&#123;
    cout&lt;&lt;&quot;Data:&quot;;
    for(int i=0; i&lt;(int)data.size(); i++)
        cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
&#125;

void QSorter::GenNum(int n)&#123;
    for(int i=0; i&lt;n; i++)
        data.push_back(rand()%200);
&#125;

void QSorter::QS(vector&lt;int&gt;&amp; v, int low, int high)&#123;
    if(low&lt;high)&#123;
        int pivot=Partition(v, low, high);
        QS(v, low, pivot-1);
        QS(v, pivot+1, high);
    &#125;
&#125;

int QSorter::Partition(vector&lt;int&gt;&amp; v, int low, int high)&#123;
    int x=v[low];   //第一个数是枢轴
    int i=low;      //比枢轴小的左部分最后一个数的下标

    for(int j=low+1; j&lt;=high; j++)
        if(v[j]&lt;x)&#123;
            i++;
            swap(v[i], v[j]);
        &#125;
    //找到比枢轴小的数就把它放第i个数后，i+1扩大左部分
    //循环结束时是中左右结构
    swap(v[i], v[low]);
    return i;//和左区第一个数换位，形成左中右结构
&#125;

void QSorter::QSort_DM()&#123;
    QS(data, 0, data.size()-1);
&#125;

int main()
&#123;
    QSorter s1(10);
    s1.OutData();
    s1.QSort_DM();
    s1.OutData();
    return 0;
&#125;</code></pre>
<p>快排的思想也很好理解，每次把比基准数小的放左边，大的放右边，每次分割区间都形成左（小于基准）中（基准数）右（大于基准）的结构。最后传给递归函数的子区间大小为1时，排序结束。</p>
<p><a href="http://blog.csdn.net/morewindows/article/details/6684558">两侧扫描的分区法</a>有一个大神讲的非常棒。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>XposedBridge 源码浅析</title>
    <url>/2015/02/15/Xposed-source-analyze/</url>
    <content><![CDATA[<p>开发Xposed模块必须用到XposedBridge。这个jar包提供了Xposed的功能。代码很少。现在来分析它的功能：</p>
<h2 id="工具类"># 工具类</h2>
<h2 id="ixunhook">IXUnhook</h2>
<p>接口类，内部有待实现的<code>unhook()</code>方法。</p>
<h2 id="xcallback">XCallback</h2>
<p>抽象类。内部声明<code>Param</code>静态类。</p>
<h2 id="类"># 类</h2>
<h2 id="ixposed">IXposed</h2>
<p>这些都是接口类。实现具体的Xposed模块必须先实现这些接口。<code>IXposedMod</code>是空的接口。另外几个接口都实现这个接口。</p>
<h2 id="ixposedhookzygoteinit">IXposedHookZygoteInit</h2>
<p>内有待实现的<code>public void initZygote(StartupParam startupParam)</code>方法，每次zygote启动时调用。StartupParam是接口内的静态类，实际类型是String，存放类的路径。</p>
<h2 id="ixposedhookloadpackage">IXposedHookLoadPackage</h2>
<p>主要的hook操作由它进行。内有<code>public abstract void handleLoadPackage(LoadPackageParam lpparam)</code>每次调用app的包时发挥作用（在官方教程中也是以这个作为的例子）。内部静态类<code>Wrapper</code></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>搬迁博客后的一些感想</title>
    <url>/2015/01/08/after-move-blogs/</url>
    <content><![CDATA[<p>学分大的课全考完了，今天继续把<a href="http://blog.csdn.net/u011714944/">以前的博客</a>从csdn搬到了这里，然后全部搬完了。看到以前的博客，感觉第一遍学习时很多东西仅仅停留在掌握上，认识还不够深刻。就比如之前写的迷宫生成的程序，这学期末有个老师的班上也布置了这个作业，我看到我们班上有个选这个老师的课的同学，他的算法和我的略有不同（直接挖迷宫，不假设有“小房子”）。用他的算法生成的迷宫只有一条通向终点的路径，用我的方法可以有一条以上的路径。但我暑假写这个程序时却没思考过如何生成只有一个到终点的路径的迷宫。还有动态规划，以前也理解的很浅。现在看看一些以前写的代码，感觉就一<strong>烂</strong>字。</p>
<p>这学期自学了一点8086汇编，还写了一个安卓的播放器app，再后来又在写一个linux下的小工具。后来因为一些事情，原先的计划就都停下了。这学期一直没更博客。虽然大二很忙吧，但是也可以采取先挖个坑，以后再填上的办法嘛！</p>
<p>再回头来说对所学东西的认识这个问题。我现在觉得掌握和会用只是学东西的第一步。照着网上或教科书上的教程写个东西，或是用用别人的轮子，这都不算什么。我觉得能把书上东西弄懂，自己还会变通使用才行。用别人的轮子，自己还能修改，甚至别人把你的修改合并进来，那才算厉害。</p>
<p>还有学校开的专业基础课要学好。学好不全是指考试好，而是对学了什么，能用到哪里清清楚楚。实践才是最主要的。考试毕竟和实用还有很大差距。不过一般到了能用的水平，考试也就不会太差了。学校的课程虽然实践性不强，但是所学都是计算机科学的基础，只可惜这些课程大多也只讲授最基本的内容。我觉得对计算机本身构造的理解和算法的设计能力是在学校期间应该非常注意培养。简言之就是：底层+算法。如果对科研有兴趣的话还应该额外看一些数学和算法方面的书。计算机是门实用的学问，任何离开实际去学习的方法都是不可取的。最好的学习方法就是多动手。学习时多把书上看不明白的地方自己实现一遍，自己有好的想法也要实现一遍。以后工作的话估计很忙，能自由支配的学习时间可能不会很多。</p>
<p>另外，自己要培养自己的工程能力。说实话我现在做的还很糟糕，因为目前还没有项目经验（自己写的小玩意儿不算）。不过这不着急，毕竟上学期和这学期还在打基础，而且其实这个学期也做了一些准备工作了。下学期我看看有什么好的机会，要争取参加。</p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴内推实习面试经历总结和记录</title>
    <url>/2016/04/12/alibaba-intern-tst/</url>
    <content><![CDATA[<p>今年3月初大概6号的时候在校园BBS论坛上找到了一个学姐帮忙内推阿里巴巴。过了约10天开始进入了内推面试流程。人生头一次面试一个公司并且一路面到了HR面，按照HR的意思是最后一面了，据说面试结果要过一段时间才会通知（该不会挂了吧-_-||）。不管怎样，这是人生一次宝贵的经历，记下这次经历，以时刻警醒自己。</p>
<h1 id="大致情况">大致情况</h1>
<hr />
<p>在学校情况大概是这样：之前只做过1个项目（安卓恶意APP批量检测工具，用了机器学习方法），参加过数学建模得了两个校内赛奖和省三等奖，和同学5人参加过15年和16年ASC竞赛（不过都没进决赛），大一得了国奖，大二得了学校的一等奖学金。技术上兴趣还是自认为比较广泛的，虽然之前搞过的安卓弃坑了。比较擅长C/C++，Java与python略懂。我比较赞同在理论知识掌握牢固的前提下进行技术学习（技术指某门具体的应用技术），多看书，不要“无脑”的写代码。</p>
<p>总之技术经历挺平淡的，挺像一个读书读多的“书呆子”，并没有一堆吊炸天的项目和开源的东西。</p>
<p>我投的是C/C++研发。我没选意向部门，简历被支付宝拿到了（但简历里有个问题是你想到阿里哪个部门，我写的阿里云，因为知道他们用C/C++，而且了解到貌似他们主要做云计算和大数据平台这块）。</p>
<h2 id="初面">初面</h2>
<p>初面面试官问的问题都很偏向基础的技术知识。正因如此，我对初面的印象最深刻。听声音面试官应该比较年轻。第一次打电话是周三，当时在上课，幸好坐在教室中间周围全是人，装作捡东西接听了一下，告诉他我在上课（当时傻了，没约下次电话时间）。第二次就是一周后的周五晚上快十点了（应该在加班吧）。那个时候打电话我挺惊讶的，也挺感动的（那么忙还要面试实习生）。</p>
<p>问题有这么几个：</p>
<ol type="1">
<li>自我介绍。我主要把我上面的大致情况讲了一下，但没说我对学习技术的看法，只谈了获奖和项目经历。</li>
<li>谈谈傅里叶变换。不会。其实之前在知乎和推酷上看过一个带动图的回答，还是有些印象，但是仅仅听说过的话还是就说不会好点。然后面试官问我你们专业都学过哪些数学课，我说微积分，线性代数，概率论与数理统计、离散数学，然后就没再问数学了。</li>
<li>听说过或用过C++的NIO网络模型没。我说我只知道Java有NIO一个包，C++下好像没这个东西，我不知道。然后就没再问了。我总怀疑是不是听错了，因为后来查了下，确实没C++的NIO。</li>
<li>讲讲快速排序。这个答的自我认为比较好，因为以前还专门写了博客。然后让在collabedit.com上手写快排。事后才知道这个网站是专门用来面试的。不过可能晚上打游戏看视频的人太多，网抽风了。我敲好了代码对面说没看见，过了几秒网页就显示链接断开，然后一刷新什么都没了，所以最后面试官还是没看见我写的代码。。。</li>
<li>用过数据库没。我说mysql。然后让谈谈对mysql锁的认识。不会。</li>
<li>网络协议栈几层？介绍下。我答的5层（主要好举每层协议的例子）因为做过一个课程设计是从抓的数据包里还原HTTP报文信息，所以答的还可以。</li>
<li>介绍简历中的项目（比赛中负责什么，C语言套接字编程学到什么程度，课程设计HTTP协议还原，安卓恶意app批量检测工具项目介绍一下）。</li>
<li>问随机森林算法，怎么训练的，知道过拟合么？我说随机森林不会过拟合。然后问为什么，讲了一通。然后问做项目的时候你们怎么衡量机器学习算法的好坏，我说的是交叉验证+测试准确率，另外可以看TPR,FPR,TNR,FNR，外加ROC曲线和AUC值（顺便解释了ROC曲线是干啥的）。面试官问ROC曲线怎么画的，解释了一下。</li>
</ol>
<p>面试时间大概40分钟多一点，大概面完15分钟，简历状态就是“面试中”了。</p>
<p>我的感受是，只要项目在一年内做的，没有夸大成分，简历项目问题应该都能答出来。一面偏向基础，常见算法要会。同学有一面问mysql索引的，B+树的，HashMap和ArrayList的，当然他面的Java。只是说做项目要深挖知识点，多思考，注重基础和常考的面试问题。</p>
<p>人生第一次面试，一开始说话都没力气。后面好了一些。</p>
<h2 id="二面">二面</h2>
<p>二面面试感觉是最有意思的，面试官也很有意思，问的问题也很不一样（不是那种背书问题）。一开始还是自我介绍。让我说了下OpenMP是什么（主要因为竞赛的时候用了）。快速排序原理（估计一面面试官跟他说了没写代码的事）。怎么并行化快速排序（一时没想起来，有一个专门的并行算法，并不是递归的时候创建线程递归就行），因为不知道怎么答，所以我说并行快速排序容易造成负载不均衡，一般归并排序并行好点。然后就被要求并行化归并排序（我说了一下外部排序和归并过程）。最后又问机器学习。其中一个问题没答出来：ROC曲线如果相交，AUC值也差不多，你怎么判断哪个方法好？</p>
<p>大概时间还是用了40分钟，最后被问实习时间，我说7月1到9月1。然后让我提问，我问了下一共要面试几次（官网上说3次，但网上说4和5次的都有）。</p>
<h2 id="三面">三面</h2>
<p>三面是最短的一次，只有20多分钟，面完以为挂了（间隔了一周多才到HR面）。主要问简历项目。面试官很喜欢质疑，比如：你们做的项目学校在项目答辩后看代码么？我说看，因为文档和代码让提交。他说：如果只是走走形势呢？我说做项目时要发论文，老师总要看看东西吧。其实有一点我没说，面试官估计也清楚吧，就是现在学校里有些老师都是到处接活，至于做成啥样，能用，能发文章就行，代码的话很多老师自己都不怎么写了，所以也不关心。反正这个问题个人感觉没答好。</p>
<p>之前还问了：你学技术的动力是什么？我说就是觉得好玩，解决问题很有意思，搞技术挺酷的（实话，当年高考报专业全是计算机和电子信息类的）。貌似面试官表示很怀疑。我相信大部分长期写代码的都是最初觉得好玩才学写代码的。但是，我感觉我理解错他意思了，他应该是想强调<em>学技术是长期的事情，你怎么坚持下来的</em>，这恐怕是他真正关心的。</p>
<p>还有：看你经历挺丰富，万一你哪天对别的东西感兴趣了，那你之前的技术怎么办？我说我并不是见什么都感兴趣，我会对技术有个大致了解再决定是否继续深入。我说了我搞安卓的例子，说不打算搞移动端开发了。又被问为什么？我说我偏向解决基础性的问题，移动端还是比较面向业务和需求，不太符合我解决问题这个兴趣点。看来我是傻了，现在想想，对方是怕你<em>太随性，不能坚持</em>。但我觉得一个程序员应该对新技术始终保持跟进，感兴趣是动力啊。了解一个新技术，不代表你整个技术领域都改变。而是其它技术或许可以为解决问题提供参考和新思路。比如：机器学习技术可以跨界应用到安全领域，一个人做安全的人如果视野很窄不愿意学习，那么很难把这个新兴技术应用到自己的领域。</p>
<p>总之，搞技术的人在非技术的阅读理解和表达上是很容易产生偏差的，要<em>想想再说</em>。</p>
<h2 id="hr面">HR面</h2>
<p>面试官是个大姐。第一次电话是上午上课，幸好坐中间了，假装捡东西，接了电话，约了中午。我以为一点多会打过来，就没睡觉。前一天熬夜了，困得不行，就躺着玩手机。大概是HR午休或者考虑到学生午休吧，两点半打过来了（早知道睡觉了T_T）。</p>
<p>先让自我介绍。然后问我实习动机，我说增加大企业实习经历，因为以前没实习过，也希望获得转正式员工的机会。</p>
<p>之后问技术上关注擅长什么。我说C/C++还有机器学习。于是就问为什么是这2个技术。我说能解决问题，偏向基础，我想做偏基础的东西，偏向业务和应用的不太感兴趣。作了个大死又说了安卓，我说框架什么的这些老是在变，不想被Google这种大公司牵着鼻子走，也不想老是根据需求不停地改app之类的东西。然后被批评了，说技术要面向市场需求。然后问知道阿里做服务器用什么？中间件知道么？我说Java（今年年初发现了阿里好几个团队的博客，所以这个还是知道的）。又问为什么投C/C++？我说这是我擅长的，参加的ASC比赛也是这方面的，兴趣也在这里。结果面试官说你这不是擅长，你是只投你会的，因为你们学校里做项目老师让用什么你们就用什么，学校作业也是C/C++，你的技术视野太窄了，因为你接触的只有这些，所以就只投这些，阿里做服务器的都是Java，C++都是做挖掘用的（但是他们网站上写的分布式，云计算和系统内核）。我就只好说：擅长的肯定是我会的，不会的东西也就谈不上擅长，所以您这么说没错。而且我才大三，就这几年也不可能把所有的技术都了解一遍（我想就算是工作了的人也不会每种技术都懂）。语言只是解决问题的工具，最重要还是能够解决问题的知识和思路。结束时候让我提问，我说了下自己估计的实习时间，问我的岗位转正可以么？回答是表现好才可以，没转正的话校招可以直接开始面试环节，而且更沾光。如果实习时间不能达到2个月，那还不如别来。</p>
<p>技术视野不够这个问题很难界定，因为了解太多会被扣上“多而不精”的帽子，了解太少又成了“不愿学习”，“没有学习新技术的动力”。所以这个问题我就没继续回答。</p>
<p>当时还是被HR的问题弄懵逼了。应该说：招聘网站上写的是做分布式的，然后顺便提一下自己简历上有除了C++外的项目（总感觉他们想找个写Java的）。</p>
<p>对于学校里只用C++这点，完全不对。至少在我们学校，学生工作室全是做Web开发的，都是Java, js, python一类的。学校老师的项目用Java绝对是主流，甚至还有python的（上离散的时候授课老师亲自说他们都用python）。可以说，这几年我是完全凭个人兴趣在学C++。我学Java的时间是大一寒假，虽然比C++晚，但是我并没有只学C++。甚至我的博客里，技术文章中用到Java的占到了一半以上。只是C++是个很大的主题，至今还有很多东西没有学习到，所以没有写很多博客。我为什么学C/C++？原因很简单：它偏向基础，偏向底层。现在的计算机科学世界就是C/C++上搭建起来的。看看Linux/Unix，mysql，nginx，Java虚拟机，各种语言的解释器编译器，深度学习（GPU编程）。如果你不懂C/C++，那么上面所有这些你都别想深入研究。</p>
<h1 id="总结">总结</h1>
<p>基本技术要过关。我列个单子，以后继续努力：</p>
<ul>
<li>sql的所有指令都要看一遍，然后要有意识的搜集mysql各种面试问题。</li>
<li>不看书能够手写各种常见算法数据结构，刷题技术过关。我一个同学跟我说程序员怎么能背代码呢？我觉得代码确实不是靠背的，但是作为一个基础有待考察的在校生，还是去准备这些东西吧。</li>
<li>C/C++基础。没问的东西不代表以后不考或可以不看。当然C++11/14就不必看了。</li>
<li>Linux网络编程，多线程：挑选APUE的部分章节看，看man手册，动手做东西。</li>
<li>网络协议：学校里学的差不多够了。经常问问自己为什么协议设计成了这样，这么做是干什么？据一些同学说《TCP/IP详解1》是好书。</li>
<li>操作系统的知识，课本内容差不多也够了。</li>
</ul>
<p>还有就是技术兴趣点和学习动机这个问题，真是要想好再回答。我觉得很多人学技术的动机和我差不多，但是真要答好这个问题还是要仔细准备，不然就成了给自己找麻烦了。</p>
<p>Update: 最后拿到了实习，但是因为学校和时间的原因拒绝了这个offer，确实十分可惜。</p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>暑假实习回来</title>
    <url>/2016/09/30/backhome/</url>
    <content><![CDATA[<p>暑假实习回来了。学到不少东西，有不少感想，除了技术上的，更多是其它方面的。</p>
<p>最大的一点感触就是要会表现自己，有自信，要做好宣传和推广的工作。很多时候默默工作，成绩是很难被别人看到的，必须要会总结，会汇报，会通过各种渠道宣传。当然这个前提是真要做出好的工作来。很多时候埋头技术，技术做的很厉害，但是没什么存在感，这是对个人发展很不利的。对一个团队来说也是如此，要选择好的方法把自己的技术积累展示出来。</p>
<p>展示自己的方法有很多。比如，分享自己学到的东西，或者整理自己的工作，再或者写一点有意思的个人项目。这些对个人也有好处，毕竟总结所学也是一个很重要的技能。说实话在学校里除了考试复习和偶尔写点博客之外，还真少有系统总结个人所学的时候。另外就是掌握做ppt的正确姿势。ppt不要花哨，但要做出震撼力，把核心的东西展示出来，用重点内容打动听众。参加了几次技术分享以后真心觉得这很重要。</p>
<p>第二，多问业务上的问题。作为一个新人，就算技术基础还可以，业务上的经验也是0。之所以要掌握这个技能是因为：很多时候技术资料是全的，但是组里和部门解决怎样的问题确实没有资料和文档可查。而且，业务和架构也是很长时间积累来的，一时半会儿肯定摸不清，与其自己满世界找资料，不如请教专门负责这些部分的人。这里问问题是有方法的：</p>
<ul>
<li><p>1.搞清楚组里每个人都在做什么，负责什么内容。这个是一个大的前提。我这里做得一开始不好，到来了很长一段时间才意识到这个严重性。幸运的是意识到问题的时候组里的人我都认识了，而且也零散的请教了很多问题，对他们的工作有了基本了解。如果时间倒流的话，第一周我就要把这个全弄清楚。</p></li>
<li><p>2.找个组里的老员工，听他扯扯组里项目的发展史。我进入组里后，和几个新人听前辈讲了组里业务的发展，技术的改换过程，感觉很受益。</p></li>
<li><p>3.如果有运维的工作，争取做一下。通过维护系统，可以对整个系统有个更直观的理解。</p></li>
</ul>
<p>第三，要制定自我提高的计划，时刻保持学习的状态。毕竟工作和学校学习有很大不同。工作以后学习时间减少，而且要花更多的时间在管理自己的生活上。以前那种想学就去学的时间和机会都没有了，学习必须挤出时间来。这个方面目前还没有很好的方法，将来还是要多请教其他人。</p>
<p>最后，坚持锻炼。我体能并不怎么好，也不是很壮。但是来实习以后组里人觉得我看上去体力很好。。。这只能说明工作后大部分人体能都退化了。坚持锻炼其实很难做到，因为人总是懒。我很佩服我的导师，在我来实习这段时间他也开始了个人的锻炼计划。两个月最后减掉十几斤。其实他就是每天晚上都去跑步，然后不吃晚饭。锻炼这个和上面制定计划这个，都需要有执行力。锻炼也有很多，除了专门去跑步外还可以多爬楼梯，多参加其它体育活动。</p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象的默认初始化和值初始化</title>
    <url>/2016/11/14/cpp-init/</url>
    <content><![CDATA[<p>注：如果赶时间可以直接跳到下一小结阅读。</p>
<p>今天一个朋友问我一个问题，由此引发了我对C++对象初始化方式的深入研究。他问我这段代码有什么问题没有？</p>
<pre><code>tm *t = new tm;

t-&gt;tm_year = 2016;
t-&gt;tm_mon = 5;
t-&gt;tm_min = 9;
t-&gt;tm_hour = 9;
t-&gt;tm_sec = 30;
cout &lt;&lt; mktime(t)&lt;&lt;endl;</code></pre>
<p>我第一反应是time_t格式不能直接cout，直接cout得不到格式化的时间。当然这个不是重点，他告诉我每次结果都是随机的！我这才反应过来是new的问题。因为new在堆上分配的空间是没有初始化的。</p>
<p>然后我打算告诉他在main函数外的全局部分定义一个变量，但是在我消息发送出去前，他又告诉我他把代码的第一行修改成了下面这个形式，然后就初始化成固定值了：</p>
<pre><code>tm t1;</code></pre>
<p>他问我是不是这样做就总是固定值呢？我认为这个对象是栈上的，印象里这个是没有初始化的。所以回答只是编译器的问题。然后我提供了一个使用指针的的方法：</p>
<pre><code>tm *t = new tm();</code></pre>
<p>之后他问了一个关键的问题：“如果不加括号是不是一定就不会去自动的调用相关的初始化部分？”</p>
<p>我开始回答的是：如果是个类的话，会调用。基本类型不会。</p>
<p>但是后来想想不太对，因为我印象中确实有的在函数里定义的临时类是没有经过初始化的。但当时在外边没有电脑。回去后在 Windows 环境下用 gcc(codeblocks) 和 VS2015 都试了一下，然后查了cppreference，大概明白是怎么回事了。</p>
<p>首先经验证，new的时候加括号可以得到想要的结果： <img src="/img/cpp_init/pic_new1.png" alt="pic1" /> <img src="/img/cpp_init/pic_new2.png" alt="pic2" /></p>
<p>但是，直接在函数内部定义结构体变量，gcc和vs得到了不同的结果： <img src="/img/cpp_init/pic_gcc_vs.png" alt="pic3" /></p>
<p>这说明结构体内部的成员没有初始化。</p>
<p>为了搞清所有的情况，查了下cppreference，并按照C++11的标准写了下面的内容：</p>
<p>下面介绍C++对象两种重要的初始化方式：默认初始化和值初始化。主要参考cppreference写成的。并且删除了其中过时的部分（主要都是C++03的特性）。</p>
<h1 id="默认初始化">默认初始化</h1>
<p>默认初始化的语法：</p>
<pre><code>T object;
new T;</code></pre>
<p>在以下情形，会使用默认初始化：</p>
<ol type="1">
<li>当变量具有自动，静态，线程生存周期，并且没有初始化时。</li>
<li>使用<code>new</code>动态分配的对象没有初始化</li>
<li>在一个类中，当某个基类或者非静态成员在构造函数初始化列表中没有出现，并且该构造函数被调用的时候。</li>
</ol>
<p>默认初始化的效果：</p>
<ul>
<li>如果T是一个非<a href="http://en.cppreference.com/w/cpp/concept/PODType">POD</a> (Plain Old Data)类型，就会在列表为空的构造函数，以及重载的构造函数中选择一个（注：可能有构造函数参数列表非空且所有的参数都有默认值）。被选中的这个构造函数会初始化变量。</li>
<li>如果T是数组类型，每个元素都被默认初始化。</li>
<li>否则，什么也不做：自动生存周期的对象（包括他们的子对象）值都是未定义的。</li>
</ul>
<p>#值初始化</p>
<p>值初始化的语法：</p>
<pre><code>T();    (1) 
new T ();   (2) 
Class::Class(...) : member() &#123; ... &#125;    (3) 
T object &#123;&#125;;    (4) (since C++11)
T&#123;&#125;;    (5) (since C++11)
new T &#123;&#125;;   (6) (since C++11)
Class::Class(...) : member&#123;&#125; &#123; ... &#125;    (7) (since C++11)</code></pre>
<p>在以下情形使用值初始化：</p>
<ul>
<li>1,5) 当使用内部为空的圆括号或花括号创建一个无名的临时对象时。</li>
<li>2,6) 当用<code>new</code>创建一个动态对象，且后面使用了内部为空的圆括号或花括号时。</li>
<li>3,7) 在某个类中，当某个非静态成员或基类使用了空的花括号或圆括号初始化时。</li>
</ul>
<p>初始化的效果：</p>
<ol type="1">
<li>如果类型T是有至少1个用户定义的构造函数，那么调用默认构造函数。</li>
<li>如果T没有默认构造函数，或者有用户定义的构造函数，或者默认构造函数是删除的，那么使用默认初始化。</li>
<li>如果T不是Union且无用户的构造函数，那么所有的非静态成员和基类采用值初始化。</li>
<li>如果T是个有默认构造函数的类，且这个构造函数不是用户定义的也不是删除的，那么该对象被<a href="http://en.cppreference.com/w/cpp/language/zero_initialization">零初始化</a>。然后，如果它有一个non-trivial的默认构造函数，它将被默认初始化。</li>
<li>如果T是数组，每个元素都被值初始化。</li>
<li>否则都执行<a href="http://en.cppreference.com/w/cpp/language/zero_initialization">零初始化</a></li>
</ol>
<p>关于第3条很难理解。首先，trivial的定义参考这个<a href="http://stackoverflow.com/questions/3899223/what-is-a-non-trivial-constructor-in-c">链接</a>。明确了这个定义，看看下面的代码：</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#include &lt;type_traits&gt;

using namespace std;

class A&#123;//non-trivial
    int a;
    int b;
    char c;
public:
    A()&#123;
        cout &lt;&lt; &quot;it works!&quot;&lt;&lt;endl;
    &#125;;
&#125;;

class B&#123;//trivial
    int a;
    int b;
    char c;
&#125;;

int main()
&#123;

    A *a = new A();
    B *b = new B();

    cout&lt;&lt;is_pod&lt;A&gt;::value&lt;&lt;endl;

    return 0;
&#125;</code></pre>
<p>运行结果表明a指向的对象的成员是随机的，并且输出了"it works"，而b指向的成员的对象全部是0。</p>
<p>A的构造函数尽管是空的，但是它是用户定义的，因此是non-trivial，进行默认初始化。参考默认初始化条的效果，由于A不是POD类型，那么就会执行A的默认构造函数（我们定义的那个）。由于我们定义的构造函数没有初始化任何数据成员，因此A成员的值是随机的，并且输出了信息"it works"。</p>
<p>B的构造函数有编译器合成，是trivial的，它符合第三条，执行零初始化。</p>
<h1 id="总结">总结</h1>
<p>根据以上内容，我总结了2点帮助记忆：</p>
<h2 id="第一点">第一点</h2>
<p>第一点是关于两种初始化发生的条件的：</p>
<p>只要使用了括号（圆括号或花括号），就是值初始化。可以简单理解为括号提醒编译器你想要用某个值赋给对象。</p>
<p>没有使用括号，就是默认初始化。可以简单理解成，你不加任何东西，编译器就会使用默认的行为。</p>
<h2 id="第二点">第二点</h2>
<p>第二点是关于两种初始化的效果的：</p>
<p>默认初始化：总是试图使用默认构造函数初始化对象。但是它对于POD类型则不这么做。比如：C基本类型，聚合类型，POD类型的数组。C语言的struct以及基本类型如果不初始化也是随机的值，和这个POD类型在C++类似。我们可以简单理解为：总使用默认构造函数，同时兼容C。</p>
<p>值初始化：我们观察几个条件可以发现，大部分情况下（效果2里包含默认构造器被删除的情况），只要用户指定了默认构造函数，那么就执行默认初始化。并且，如果编译器合成了构造函数，执行零初始化。另外，对于数组和其它情况是值初始化。而且排除掉数组后，基本类型的值初始化都是零初始化。综上，可以简单理解为：有用户定义构造函数，就执行用户定义的构造函数，否则都使用零初始化。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法搜索总结</title>
    <url>/2014/08/13/deep-back-search/</url>
    <content><![CDATA[<p>最近在看回溯搜索算法，觉得值得总结一下。</p>
<p>回溯法简单说就是，为了搜到合适的解做出尝试，尝试失败时就退回到之前状态，然后尝试其他的可能性。这类算法套路比较固定。总的思想我概括为：搜到就输出，搜不到就返回，符合条件就搜。</p>
<p>流程用文字描述，大概分为两类情况：</p>
<p>1.当搜索过程每前进一步，会遇到多种情况时：这类情况的代码形式上类似图的深度遍历</p>
<pre><code>void search(int k)&#123;
    if (达到目标) 输出解
    else
       for each(所有可能情况)
       if (满足递归条件)&#123;
         保存状态
         search(k+1)
         恢复之前的状态
       &#125;
&#125;</code></pre>
<p>2.当搜索过程每前进一步，只有两种选择时：这类情况的代码形式上类似二叉树的先根遍历</p>
<pre><code>void search(int k)&#123;
   if (达到目标) 输出解
   else&#123;
      if(符合选择1条件)&#123;
        保存状态和数据
        search(k+1, 参数1）
        恢复
      &#125;
      if(符合选择2条件)&#123;
        保存状态和数据
        search(k+1, 参数2）
        恢复
      &#125;
   &#125;        
&#125;</code></pre>
<p>当然不一定所有问题都严格遵守上面的步骤。比如，有的时候搜索的分支可能并没改变数据（之后有举例），这时保存数据这步是可以没有的。</p>
<p>回溯法的优点在于省内存，搜索过程中产生解空间。由于采用了递归和深度优先的策略，最大耗费空间仅仅和搜索的最大深度有关。</p>
<p>第一个例子，给出n和m，从1到n中挑出m个数，产生所有可能的排列数和组合数，n小于10：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

bool used[10]=&#123;false&#125;;//数字i是否使用过
int num[10];//n,m smaller than 10

int id1=0, id2=0;

vector&lt;int&gt; num2;
bool used2[10]=&#123;false&#125;;

void p(int n, int r, int k)&#123;
    if(k==0)&#123;
        id1++;
        cout&lt;&lt;id1&lt;&lt;&quot;: &quot;;
        for(int i=r; i&gt;=1; i--)cout&lt;&lt;num[i];
        cout&lt;&lt;&quot;\t&quot;;
    &#125;else&#123;
        for(int i=1; i&lt;=n; i++)&#123;
            if(!used[i])&#123;
                num[k]=i;
                used[i]=true;
                p(n,r,k-1);
                used[i]=false;
            &#125;
        &#125;
    &#125;
&#125;

void permutation(int n, int r)&#123;
    p(n,r,r);
&#125;

void c(int n, int r, int k)&#123;
    if((int)num2.size()==r)&#123;
        id2++;
        cout&lt;&lt;id2&lt;&lt;&quot;: &quot;;
        for(int i=0; i&lt;num2.size(); i++)cout&lt;&lt;num2[i];
        cout&lt;&lt;&quot;\t&quot;;
    &#125;else&#123;
        for(int i=k; i&lt;=n; i++)&#123;//i=k,保证排列结果是由小到大输出
            if(!used2[i])&#123;
                num2.push_back(i);
                used2[i]=true;//save
                c(n,r,i+1);//search
                used2[i]=false;
                num2.pop_back();//go back

            &#125;
        &#125;
    &#125;
&#125;

void combination(int n, int r)&#123;
    c(n,r,1);
&#125;

int main()&#123;
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    cout&lt;&lt;&quot;permutation:&quot;&lt;&lt;endl;
    permutation(n,m);
    cout&lt;&lt;endl;
    cout&lt;&lt;&quot;combination&quot;&lt;&lt;endl;
    combination(n,m);
    return 0;
&#125;</code></pre>
<p>当然上面的例子是输出所有的排列和组合。大部分时候我们只是搜索特定的一个结果，或某些结果。因此舍弃不必要的解是很重要的。这就涉及限界，或者说剪枝。如果搜索到某一步时再接着搜肯定没有结果，那么就停止在这个分支的搜索，通常用一个限制条件或外加判断函数来判断。</p>
<p>第二个例子，给定一个集合，知道它有n个元素，希望从n个数中取出若干个使得它们的和为c。第一行输入n和c，第二行输入集合内的数。把可行的数字组合（1组就行）输出，如果没有符合条件的组合，就输出NO SOLUTION。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
using namespace std;

int n,c;
int a[9000];
int r=0, mi[9000],s[9000], l[9000];
//s=sum, mi=min, l=answer list
void work(int x, int z)&#123;
    if(z==c)&#123;
        for(int i=1; i&lt;=r; i++)&#123;
            cout&lt;&lt;l[i]&lt;&lt;&quot; &quot;;
            if(i==r) cout&lt;&lt;endl;
        &#125;
        exit(0);
    &#125;else&#123;
    //限制条件，如果当前的和加上剩下所有的数超过目标值，且当前的和加上剩下最小的
    也不超过目标值则继续搜索
        if( x&lt;=n &amp;&amp; z+mi[x]&lt;=c &amp;&amp; z+s[x]&gt;=c)&#123;
            if(z+a[x]&lt;=c)&#123;//do1, add a[x], when a[x] can be added
                r++;
                l[r]=a[x];//save

                work(x+1,z+a[x]);//do1

                r--;//back
            &#125;
            work(x+1,z);//do2, not to add a[x]
        &#125;
    &#125;
&#125;
/* 
    x增加时有两个选择，将下一个数挑出，或者不挑出，所以有do1和do2两个选择
*/

int main()&#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;c);
    for(int i=1; i&lt;=n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);

    mi[n]=s[n]=a[n];
    for(int i=n-1; i&gt;=1; i--)&#123;
        if(a[i]&lt;mi[i+1]) mi[i]=a[i];
        else mi[i]=mi[i+1];
        s[i]=s[i+1]+a[i];
    &#125;
    work(1,0);

    cout&lt;&lt;&quot;No solution!&quot;&lt;&lt;endl;
    return 0;
&#125;</code></pre>
<p>有的时候在递归过程中一些结果可能会被重复搜索（即：走了不同的路线，但是到达了相同目的地 -_-|| ），我们还可以建立一个表储存搜索过的结果，如果发现搜过这个结果了，就不要继续递归，直接从表里读取，这样能避免大量的重复递归。这个实现起来相对容易，就不再举例了。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习总结1</title>
    <url>/2016/07/09/design-patterns/</url>
    <content><![CDATA[<p><strong>说明：这是一个个人学习的入门性总结，而且其中多是一些个人的理解，没有什么抄书的内容。所以如果有问题请指出。</strong></p>
<p>常见的设计模式分为3类：创建型，结构型，行为型。分别用来完成对象的：创建、组合、交互和职责分配。</p>
<h2 id="创建型模式">创建型模式</h2>
<h3 id="抽象工厂">抽象工厂</h3>
<p>这个模式用来创建一个“系列”产品，简化创建过程，并让客户类不再操心具体的创建细节。比如假设现在你在玩一个游戏，游戏主人公可以用手头的材料合成成套的盔甲。盔甲的材质有皮，铁，黄金，钻石。在不同的环境下，你希望使用不同的盔甲套装（比如一般情况下穿皮甲方便行动，外出穿铁甲加强防护，打怪的时候穿金套装）。显然每次根据不同的情况"new"一堆装备是很麻烦的。为了让不再每次都操心具体的创建过程，并且保证每次创建的装备的材质都一样，可以声明一个抽象工厂类，在其中声明一些抽象方法用来创建一套完整的装备。到具体要创建东西的时候，调用实现了这个抽象类中抽象方法的具体类就可以了。抽象工厂的每个具体类负责创建具体某种材质的套装。显然为了让套装中的每种装备（比如头盔，外套）有不同的材质，每种装备都应该声明为抽象类，这样不同材质的装备就可以从基类派生出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helmet</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coat</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoldHelmet</span>:</span> <span class="keyword">public</span> Helmet&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;use GoldHelmet&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoldCoat</span>:</span> <span class="keyword">public</span> Coat&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;use GoldCoat&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronHelmet</span>:</span> <span class="keyword">public</span> Helmet&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;use IronHelmet&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronCoat</span>:</span> <span class="keyword">public</span> Coat&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;use IronCoat&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArmorFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Helmet* <span class="title">MakeHelmet</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Coat* <span class="title">MakeCoat</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoldArmorFactory</span> :</span> <span class="keyword">public</span> ArmorFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Helmet* <span class="title">MakeHelmet</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> GoldHelmet;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Coat* <span class="title">MakeCoat</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> GoldCoat;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronArmorFactory</span> :</span> <span class="keyword">public</span> ArmorFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Helmet* <span class="title">MakeHelmet</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> IronHelmet;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Coat* <span class="title">MakeCoat</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> IronCoat;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Helmet *hforest, *hmonster;</span><br><span class="line">    Coat *cforest, *cmonster;</span><br><span class="line">    <span class="comment">//当你在树林里用铁甲</span></span><br><span class="line">    ArmorFactory *ia = <span class="keyword">new</span> IronArmorFactory;</span><br><span class="line">    hforest = ia-&gt;MakeHelmet();</span><br><span class="line">    cforest = ia-&gt;MakeCoat();</span><br><span class="line">    </span><br><span class="line">    hforest-&gt;use();</span><br><span class="line">    cforest-&gt;use();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当你打怪用金甲</span></span><br><span class="line">    ArmorFactory *ia2 = <span class="keyword">new</span> GoldArmorFactory;</span><br><span class="line">    hmonster = ia2-&gt;MakeHelmet();</span><br><span class="line">    cmonster = ia2-&gt;MakeCoat();</span><br><span class="line">    </span><br><span class="line">    hmonster-&gt;use();</span><br><span class="line">    cmonster-&gt;use();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的例子有两个工厂，一个负责创建金装备，另一个负责创建铁装备。另外从代码中还可以看出，工厂的指针可以作为一个参数传递，这样就可以在程序的其它地方使用工厂了。</p>
<p>另外也可以把工厂作为一个单例，因为一般来说程序中没有必要反复创建工厂类的实例。</p>
<p>最后抽象工厂有个缺点：如果在产品系列中增加新的类型（比如套装中增加了斧头），那么抽象工厂的基类和各个子类都要被修改。</p>
<h3 id="单例模式">单例模式</h3>
<p>有时候需要全局只有一个对象实例，比如刚才的工厂，当需要某种材质的套装时只需要调用唯一的工厂实例创建套装就行了。</p>
<p>解决方法是：构造函数不要声明为public。并且在类声明内定义private的该类型的静态指针变量。这样就解决了唯一性问题。为了让外部访问唯一的对象实例，还要提供一个public方法，返回唯一实例的指针。</p>
<p>代码如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_instance==<span class="literal">NULL</span>) _instance = <span class="keyword">new</span> Singleton;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Singleton();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* _instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::_instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure> 以上属于“懒汉式”单例。它在首次需要用到实例时才创建实例，而"饿汉式"则在程序开始就初始化实例。如果初始化依赖某些程序运行时的信息，“懒汉式”单例就派上了用场。</p>
<h3 id="工厂方法模式">工厂方法模式</h3>
<p>首先要介绍一下简单工厂模式。 #### 简单工厂 假设现在某个程序需要建立一个链接访问系统的某个资源。我们假设这个链接类的名子叫Connection。如果系统为该资源提供了多种访问方式，那么这个链接类也对应有很多子类（子类和访问方式对应）。如果这个资源的每种访问方式都涉及很多其它的类，操作，那么最好把这些东西都封装起来，让客户不关心Connection如何创建的。这样客户只要指定访问方式，然后使用Connection对象访问资源就行了。</p>
<p>比如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Connection con = ConFactory().createConnection(way);</span><br></pre></td></tr></table></figure> 这样就把方式当做参数传入，根据不同参数返回不同的Connection子类。ConFactory代码可能是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//。。。。</span></span><br><span class="line">    <span class="function">Connection* <span class="title">createConnection</span><span class="params">(<span class="keyword">int</span> way)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(way)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ConnectionA *con1 = <span class="keyword">new</span> ConnectionA;</span><br><span class="line">            <span class="comment">//一些准备工作</span></span><br><span class="line">            <span class="keyword">return</span> con1;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            ConnectionB *con2 = <span class="keyword">new</span> ConnectionB;</span><br><span class="line">            <span class="comment">//一些准备工作</span></span><br><span class="line">            <span class="keyword">return</span> con2;</span><br><span class="line">        <span class="comment">//。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个设计模式虽然解决了客户创建对象的问题，使得客户不再需要关心对象创建的细节，但是很明显，如果增加了Connection类型，那么类内switch部分的代码又要修改。这违背了“开放-封闭原则”。</p>
<h4 id="工厂方法">工厂方法</h4>
<p>简单工厂模式违背“开放-封闭原则”主要是因为内部的逻辑判断。为了克服这个问题，逻辑判断可以放在客户代码里。以前为了创建Connection对象要做很多准备工作，现在代码改了，怎么办？这里采取的方法是：把工厂类弄成抽象的，然后每种Connection子类对应一个抽象工厂的具体实现类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Connection* <span class="title">createConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConFactoryA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Connection* <span class="title">createConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ConnectionA *con1 = <span class="keyword">new</span> ConnectionA;</span><br><span class="line">        <span class="comment">//一些其它工作。。。    </span></span><br><span class="line">        <span class="keyword">return</span> con1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConFactoryB</span>&#123;</span><span class="comment">//。。。。。。</span></span><br></pre></td></tr></table></figure>
<p>需要用某个Connection类的时候可以这样： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Connection con;</span><br><span class="line"><span class="keyword">switch</span>(way)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        con = ConFactoryA().createConnection();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 或者如果事先知道了需要何种Connection，也可以直接用相应的工厂创建对象。</p>
<p>从上面也可以看出，抽象工厂就是工厂方法中每种工厂类可以创建一批对象的情形。</p>
<h3 id="生成器模式">生成器模式</h3>
<p>如果需要构建一个复杂的对象，甚至这个对象还需要进行一定的“组装”（各个部件之间有些联系），那么如果把生成和装配的代码分离出来会比较好。比如：现在有一个房屋生成的程序，它建造房子的流程是固定的几项（先造地基，然后是盖一定的层数，安装房顶，内部装修）。如果希望给房子选一些不同风格的部件，可以把这些盖房流程抽象成一个Builder接口。然后用不同的ConcreteBuilder类实现这些接口，这样每种具体的Builder的实现就能够盖出一个不同的房子。</p>
<p>Builder的组装受一个Director类的控制。Director调用Builder中的接口方法实现构造对象。显然Director不关心究竟怎么构建对象的。只要增加一个Builder的实现，不用修改代码，就可以让Director造一个新类型的房子。Director调用Builder里方法的顺序也不是固定的，可以根据情况进行一些动态的调整（比如GOF书里RTF文档阅读器的例子）。</p>
<p>下面的代码制造一个木头房子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WoodHouse</span> :</span> <span class="keyword">public</span> House&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildBase</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildRoof</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildFurniture</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> House* <span class="title">getHouse</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WoodHouseBuilder</span>&#123;</span></span><br><span class="line">    WoodHouse* whouse;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildBase</span><span class="params">()</span></span>&#123; <span class="comment">//..... &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>&#123; <span class="comment">//..... &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildRoof</span><span class="params">()</span></span>&#123; <span class="comment">//..... &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildFurniture</span><span class="params">()</span></span>&#123; <span class="comment">//..... &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> House* <span class="title">getHouse</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> whouse;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">House* <span class="title">HouseDirector</span><span class="params">(<span class="keyword">const</span> HouseBuilder&amp; builder)</span></span>&#123;</span><br><span class="line">    builder.buildBase();</span><br><span class="line">    builder.buildWalls();</span><br><span class="line">    builder.buildRoof();</span><br><span class="line">    builder.buildFurniture();</span><br><span class="line">    <span class="keyword">return</span> builder.getHouse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    WoodHouseBuilder b;</span><br><span class="line">    House* house = HouseDirector(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要别的房子，只要相应地增加HouseBuilder和House的子类就可以。然后调用HouseDirector方法完成组装。</p>
<h3 id="原型模式">原型模式</h3>
<p>这是本文介绍的最后一个设计模式。</p>
<p>这个设计模式主要通过“拷贝”实现对象的构造。比如，现在有个画板程序。其中有许多预置图形（继承自同一基类Shape）。为了实现快速生成一个图形对象，可以采用实现构造一个对象实例，然后复制它的方法。这样：第一，如果需要增加新的图形，那么只要继承图形基类Shape，其它代码不变即可。第二，因为只是复制对象，所以创建图形的代价会减小。为了复制对象，可以为要复制的类定义clone方法。如果在创建复制对象的时候想对复制的对象进行一些修改，可以定义Initialize方法。</p>
<p>附一个GOF书上迷宫生成器的例子： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">MazePrototypeFactory</span><span class="params">(Maze*, Wall*, Room*, Door*)</span></span>&#123;</span><br><span class="line">    Maze* _prototypeMaze;</span><br><span class="line">    Room* _prototypeRoom;</span><br><span class="line">    Wall* _prototypeWall;</span><br><span class="line">    Door* _prototypeDoor;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MazePrototypeFactory(Maze*, Wall*, Room*, Door*);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Maze* <span class="title">MakeMaze</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Room* <span class="title">MakeRoom</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Wall* <span class="title">MakeWall</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Door* <span class="title">MakeDoor</span><span class="params">(Room*, Room*)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MazePrototypeFactory::MazePrototypeFactory(</span><br><span class="line">    Maze* m, Wall* w, Room* r, Door* d)</span><br><span class="line">&#123;</span><br><span class="line">    _prototypeMaze = m;</span><br><span class="line">    _prototypeRoom = r;</span><br><span class="line">    _prototypeWall = w;</span><br><span class="line">    _prototypeDoor = d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Wall* <span class="title">MazePrototypeFactory::MakeWall</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _prototypeWall-&gt;clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Door* <span class="title">MazePrototypeFactory::MakeDoor</span><span class="params">(Room* r1, Room* r2)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">    Door* door = _prototypeDoor-&gt;clone();</span><br><span class="line">    door-&gt;Init(r1, r2);</span><br><span class="line">    <span class="keyword">return</span> door;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MazeGame game;</span><br><span class="line"><span class="function">MazePrototypeFactory <span class="title">SimpleMazeFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">new</span> Maze, <span class="keyword">new</span> Wall, <span class="keyword">new</span> Room, <span class="keyword">new</span> Door</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">Maze* maze = game. createMaze(SimpleMazeFactory);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划--寻找最长递减子序列</title>
    <url>/2014/05/31/dp-longest-decreasing-sequence/</url>
    <content><![CDATA[<p>昨天C++课上留了三道题，除了C语言本身外都涉及了一些算法。其中第二个问题是这样的：</p>
<p>拦截导弹</p>
<p>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。</p>
<p>输入</p>
<p>第一行，输入雷达捕捉到的敌国导弹的数量k（k&lt;=25），</p>
<p>第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。</p>
<p>输出</p>
<p>输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。</p>
<p>样例输入</p>
<p>8</p>
<p>300 207 155 300 299 170 158 65</p>
<p>样例输出</p>
<p>6</p>
<p>课堂上没搞出来。老师说用到了动态规划。好吧，高中没学过信息学竞赛。不过没关系，回去翻了翻《算法导论》，基本算弄明白了。其实就是求一串数的最长递减子序列。</p>
<p>问题关键在于，可能的情况组合很多，不适合穷举。所以要利用动态规划（很适合这类问题）。动态规划把问题分成很多子问题，而子问题之间又有关系。子问题不是相互独立的，子问题可能有重叠，全局最优解由子问题的最优解构成（最优子结构性质）。这和分治法（典型的比如归并排序）不一样。</p>
<p>动态规划的基本想法在于：</p>
<ol type="1">
<li>描述最优解结构，就是说最优解是什么样子的，符合什么条件。</li>
<li>递归定义最优解的值。也就是写出状态方程。其中一般需要特别考虑初始条件。</li>
<li>自底向上计算最优解的值。</li>
<li>由计算的值构造最优解（在这题里没要求，到第三部求出序列长就行了）。</li>
</ol>
<p>其中，问题设计时最关心的就是第二步。以下的步骤是必不可少的：</p>
<ul>
<li>阶段划分。</li>
<li>确定状态变量。当前状态变量是由之前阶段的某个状态转移来的。当前状态是对之前所有状态的完整总结。当前这个状态之后的选择<strong>只受</strong>当前最优决策序列的影响（无后效性）。</li>
<li>写状态转移方程。也就是确定如何从之前状态得到本阶段的状态。</li>
<li>找边界条件（开始和终止的条件）。</li>
</ul>
<p>比如说，这个问题中要拦第i个导弹。截止到第i个导弹的最长拦截序列肯定包含了前面i-1个导弹中最长的序列。如果不是这样，我们求出的截止到第i个导弹的拦截序列就不是最长的了。我们用数组D[i]把截止到第i个导弹的最长拦截序列长度存起来。最后计算完i=k（导弹总数）时，整个问题的答案就是数组D[i]的最大值。</p>
<p>如果用一个数组，把前一个最优解对应的导弹编号存下来，最后还可以把被击落的导弹高度按编号输出。</p>
<p>代码：</p>
<pre><code>/*
    设数组A存放导弹高度，D[i]是高度为A[i]是的最优解，S用于记录最优解中导弹被击落的次序
    最优解结构：设在第k个数处的最优解为D(k)。设当前位于第i个数，则在第i个数处的
            最优解D(i)为：在i之前拦下导弹最多的方法的解D(j)加上1。（因为把第i
            个也打下来了，所以加上1）。当然还要保证A[i]&lt;=A[j]
    递归解：D(i)=D(j)+1。j是数组A中位于A[i]左侧，且大于等于A[i]的所有数中D值最大的
            那个。如果A[i]左侧没有找到大于等于它的数，则D[i]=1。
    状态转移方程：D(i)=max&#123;D(j)+1&#125;  (0&lt;=j&lt;i&lt;k)
                D(0)=1
    最终结果：找到数组D中最大的数，这个数就是结果。
*/
#include &lt;cstdio&gt;
int main()&#123;
    int k;
    scanf(&quot;%d&quot;, &amp;k);
    int A[k], D[k], S[k];

    for(int i=0; i&lt;k; i++)&#123;
        scanf(&quot;%d&quot;, &amp;A[i]);
        D[i]=0;
    &#125;
    D[0]=1;

    for(int i=1; i&lt;k; i++)&#123;
        bool found=false;   //是否找到i之前的最优解
        int last_good_solve=D[0];
        int good_position=0;//最优解的下标和值
        for(int j=0; j&lt;i; j++)
            if(A[j]&gt;=A[i] &amp;&amp; D[j]&gt;=D[good_position])&#123;
                last_good_solve=D[j];
                good_position=j;
                found=true;
            &#125;

        if(found)&#123;
            D[i]=1+D[good_position];
            S[i]=good_position;
        &#125;
        else &#123;
            D[i]=1;
            S[i]=good_position;
        &#125;
    &#125;

    int result=0;   int go_back;//用于向前找被击落的导弹
    for(int i=0; i&lt;k; i++)&#123;
        if(D[i]&gt;result)&#123;
            result=D[i];
            go_back=i;
        &#125;
    &#125;

    printf(&quot;%d\n&quot;, result);

    for(int i=0; i&lt;result; i++)&#123;
        printf(&quot;%d  &quot;, A[go_back]);
        go_back=S[go_back];
    &#125;//逆序输出被击落导弹的高度
&#125;</code></pre>
<figure>
<img src="/img/dp_longest_decreasing_sequence/1.png" alt="" /><figcaption>pic1</figcaption>
</figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>git基础常用指令汇总</title>
    <url>/2014/10/05/git-commands/</url>
    <content><![CDATA[<p>远程关联操作：</p>
<p>创建自己的仓库后，要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p>
<p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p>
<p>此后，使用命令：git push origin '分支名称' 推送最新修改；</p>
<ul>
<li>克隆仓库：git clone git@github.com:GTIHUB账户名/仓库名.git</li>
<li>git remote -v 查看远程仓库详细信息</li>
<li>git branch - -set-upstream 分支名 origin/分支名 指定本地某分支与远程origin/某分支的链接</li>
<li>git pull 从服务器同步</li>
</ul>
<p>本地操作：</p>
<ul>
<li><p>git status 查看本地仓库状态</p></li>
<li><p>git add 'filename' 添加文件到本地缓存</p></li>
<li><p>git add -A 添加所有改动的文件</p></li>
<li><p>git commit -m 'commitment' 提交更改到本地并添加说明内容</p></li>
<li><p>在仓库目录下输入：git init，把这个目录变成仓库</p></li>
<li><p>git log 显示近三次的更改</p></li>
<li><p>git log --graph --pretty=oneline --abbrev-commit 查看分支图形</p></li>
<li><p>git reset --hard HEAD^ 退到上个版本</p></li>
<li><p>git reset --hard 'SHA-1编码' 退到SHA-1编码表示的版本</p></li>
<li><p>git diff HEAD -- 'FILE' 查看工作区文件与版本库文件的不同之处（可以省略HEAD后内容）</p>
<p>git checkout [选项] [<分支>] -- <文件>...</p>
<pre><code>-q, --quiet           不显示进度报告

-b &lt;分支&gt;             创建并检出一个新的分支

-B &lt;分支&gt;             创建/重置并检出一个分支

-l                    为新的分支创建引用日志

--detach              成为指向该提交的分离头指针

-t, --track           为新的分支设置上游信息

--orphan &lt;新分支&gt;     新的没有父提交的分支

-2, --ours            对尚未合并的文件检出我们的版本

-3, --theirs          对尚未合并的文件检出他们的版本

-f, --force           强制检出（丢弃本地修改）

-m, --merge           和新的分支执行三路合并

--overwrite-ignore    更新忽略的文件（默认）

--conflict &lt;风格&gt;     冲突输出风格（merge 或 diff3）

-p, --patch           交互式挑选数据块

--ignore-skip-worktree-bits 对路径不做稀疏检出的限制</code></pre></li>
</ul>
<p>git checkout -- 'readme.txt' 丢弃工作区的更改（后面--参数必须有）</p>
<p>对于提交到了暂存区的更改：先git reset HEAD file</p>
<p>删除文件时先直接把原文件删除。然后git rm '文件'，然后commit。如果是误删除git checkout -- '刚才删掉的文件'</p>
<p>在用户个人目录下：ssh-keygen -t rsa -C 'youremail@***.com' 生成密钥</p>
<p>分支管理：</p>
<ul>
<li>查看分支：git branch</li>
<li>创建分支：git branch name</li>
<li>切换分支：git checkout name</li>
<li>创建+切换分支：git checkout -b name</li>
<li>合并某分支到当前分支：git merge name</li>
<li>删除分支：git branch -d name 换成-D是强行删除</li>
<li>git merge --no-ff -m "merge with no-ff" dev 普通的合并模式</li>
</ul>
<p>BUG 修复时用到的命令：</p>
<p>修复bug时，创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<ul>
<li>git stash apply stash@{0} 恢复到指定的stash</li>
<li>git stash list 查看所有的stash现场</li>
<li>git stash pop 恢复工作并删除之前保存的现场</li>
<li>git stash 保存工作现场</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>大学二分之一过后的感想</title>
    <url>/2015/07/07/half_univ_life/</url>
    <content><![CDATA[<p>时间过得非常快。随着这个学期考试的结束我已经在大学完成了一半的学习时间。更为准确说应该是一半多的时间，毕竟大四就没什么课了。还是梳理下吧。</p>
<h2 id="这个学期"># 这个学期</h2>
<p>先说这个学期吧。这个学期简单讲就是没忙出什么名堂。而且也没再去工作室了。工作室的人是我大学里见过的非常nice的一群人（说最nice其实也不过分）。上学期我去了几次工作室发现他们都在弄安卓。尽管当时我也在学安卓，但是将来并不打算把这个作为职业方向，而且我一直很想弄的Web还有服务器还有高大上的机器学习啥的一直还没弄过啥名堂，所以后来就自己研究了。到了这个学期本以为会轻松些，可是课程非常多。另外学院的选修课程考试也非常恶心，六月后就只有复习了（从6月17考第一门到7月5号考了最后一门）。4月末的时候接了銀杏黄项目，任务是开发安卓APP恶意分析工具。因为当时我正在看Coursera的课程，感觉能用机器学习做分类，而且寒假弄的那个东西没弄成，所以又和寒假时弄信息安全竞赛没弄成的小伙伴一起接了这个项目。</p>
<p>项目进展的很慢，因为指导老师希望发论文，所以还要做出点创新来。事实是，一搜论文才发现，用机器学习做恶意应用检测五六年前国外就有很多人在做了，而且这些人的工作涉及很多方面，因此我们不大可能有大的创新。期末考试前的时间除了折腾立项，就是看了些论文。</p>
<p>开学初的超算竞赛还算可以，主要是大家对这个事情是有一定投入的，从寒假几个人自费参加主办方的培训这点就能看出来。可惜团队分工不是很好，中途还有一个人退出。最后还是差了一点点。</p>
<p>后来了解了一下LZW算法，写了个压缩文本的Demo，不过个人认为没什么用。好多时候学算法就如同背菜谱，长期不用就忘了。而且背住菜谱不代表你能够把菜做好。</p>
<p>中间有一段时间做了做Leetcode，做了两场Codeforces（被虐惨了，以前没做过，这比赛还有时差），感觉做题能力不行，估计考CCF证会有点问题，可能要专门像应付考试一样看书刷题。</p>
<p>注册了Coursera的课程，看了看前几讲，老师讲得很好理解。可惜后面因为考试就没看了，希望暑假好好补补。</p>
<p>中间有一个星期跟着网上的博客在看python，写出漂亮的python程序估计还不行，但看懂代码基本是可以的。</p>
<p>总之弄的东西很杂，平时时间碎片化很严重。。。</p>
<h2 id="前两年大事回顾"># 前两年大事回顾</h2>
<p>第一年上半学期其实没什么意思。当时太听学校的忽悠话了没带电脑，我估计很多年后想起来我还是会遗憾的。附带的“好处”是玩和娱乐的时间非常多，现在想想真是浪费生命。唯一干的事就是把Thinking in C++卷一看完了，寒假回去C++连带Java还有mySQL（寒假看的）敲了敲。</p>
<p>第二学期干了不少事，大概是最充实的了。学了Linux，数据结构，正则表达式，参加数学建模比赛，看了看Java web培训视频（没什么用，感觉现在忘得差不多了）。</p>
<p>第三学期学了点Android，做了一个难看的播放器（但是很干净，我现在用它听歌）。之前跟工作室的人说的要做的Linux指令检索工具也写好了（代码效率有点低，以后会重写）。王爽的8086汇编大概了解了一下，计算机底层的知识扫了个盲，最后看了看OpenMP和MPI（比赛时候MPI没用上，所以这个也忘得差不多了）。春节前后学了Qt，做了一个很搓的游戏。</p>
<p>学的很杂，但大部分都是我认为必须要会的。有些东西虽然会忘掉，但是再拿起书本肯定是可以想起来的。</p>
<h2 id="写在最后"># 写在最后</h2>
<p>大学本科还是偏向基础和通识，正因为如此我们才要额外自己培养自己更加专门的知识，并深入钻研。这是我目前做的不好，应该改进的地方，因为总感觉自己现在还没有特别突出的技术方向。另外时间不要虚度，应该把碎片化的时间整理好。</p>
<p>也许几年之后，大学里学的大部分知识都会忘掉。我觉得最重要的是掌握<strong>快速学习</strong>的方法，还有良好的思维习惯。最终留在我们头脑中的应该是知识的精简和抽象。我管这个叫做有关某个领域知识的知识或者知识的索引。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7 安装常见问题汇总</title>
    <url>/2014/08/07/install-centos7/</url>
    <content><![CDATA[<p>前两天把CENTOS6.5升级到了CENTOS7。其实就是重新安装了新版。网上提供了在线升级的办法，但是经过本人尝试没有成功，最后下载了ISO镜像安装。</p>
<p>在线升级的方法看<a href="http://www.oschina.net/translate/centos-6-to-centos-7-upgrade-procedure">这里</a>。但是需要先下载Preupgrade Assistant和redhat-upgrade-tool-cli这两个工具。工具下载地址在<a href="http://dev.centos.org/centos/6/upg/x86_64/Packages/">这里</a>。一共4个RPM安装包。我在测试在线升级时安装包全部下载好了，只是最后重启后安装时每次到一个地方就自动重启然后重新安装，反复了好多次。</p>
<p>最后刻了个DVD安装好了。如果没有刻录盘可以使用dd命令把iso文件刻到U盘里代替，方法：dd if=xxx.iso of=/dev/sdb (假定U盘是sdb，不过一般都是硬盘sda，u盘sdb，注意sdb后不需要加数字)。如果想恢复U盘，不要在windows下格式化（经过亲自测试容量就成了ISO文件的大小），应该在linux下格式化。命令是：mkfs -t vfat /dev/sdb1。dd指令刻录的时间比较长，大概20多分钟电脑卡住会什么反应也没有。</p>
<p>用刻好的设备(DVD或U盘)引导启动，进入安装程序会出现三行字，第一行：Install CentOS7，第二行：Test this media &amp; install CentOS7，第三行：troubleshooting。如果选第一项直接安装失败（我就是选了第一行后在一个地方黑屏左上角一个光标一直闪，然后就卡住了），就进入Troubleshooting，里边有个install centos7 in basic graphic mode。之后会进入图形界面，记住选中文界面（英语好可以无视）。按照提示安装。</p>
<p>这里我的机子出了些BUG，只要调整/boot分区大小，保存修改结果后就会自动变为3MB。好在安装程序有个自动分区功能。如果出现相同状况或者不知道分区分多大好，可以使用这个功能。</p>
<p>安装好了就会提示重启。不过重启后发现WIN7的启动选项没了T_T。以前CENTOS6.5时好歹还有个OTHER选项。。。。。。</p>
<p>GRUB启动选项的修复：在CENTOS7下不再使用GRUB1，而是改用GRUB2。从此不再有menu.lst文件，而是改成了/boot/grub/grub.cfg这个文件。里面的配置格式和指令也变了。启动选项出现时按c，进入grub的命令行模式，输入ls能查看有哪些硬盘分区。依次输入以下命令：</p>
<ul>
<li>set root=(hd0,msdos1)</li>
<li>chainloader +1</li>
<li>boot</li>
</ul>
<p>hd0是硬盘，msdos1是WIN7的C盘。如果没成功就在set root里换几个分区。如果成功了，下次进入CENTOS7，修改/boot/grub/grub.cfg，添加下面内容：</p>
<pre><code>menuentry &quot;WIN7&quot; &#123;
     set root=(hd0,msdos1)
     chainloader +1
&#125;</code></pre>
<p>这些都弄好后，去下载个显卡驱动装上，否则CPU发热超大（我的是AMD RADEON HD 8570M）。下载前注意看是不是最新版，是否支持3.10的linux内核。</p>
<p>最后，CENTOS7废除了service指令，所有服务都改用systemctl指令，如果输入service系统会自动切到systemctl。而且输入setup后进入系统自启动项目的管理页面会发现少了很多系统自启动服务。新的修改方法就是用systemctl指令。</p>
<ul>
<li>systemctl list-unit-files 显示所有服务及状态</li>
<li>systemctl start xxx.service 启动服务</li>
<li>systemctl stop xxx.service 关闭服务</li>
<li>systemctl restart xxx.service 重启服务</li>
<li>systemctl enable xxx.service 开机启动服务</li>
<li>systemctl disable xxx.service 取消开机启动服务</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>KD-Tree</title>
    <url>/2015/08/11/kd-tree/</url>
    <content><![CDATA[<p>使用KNN算法，需要找到样本点周围最近的N个点。最简单的方法是求出所有距离，然后找出前K大。然而点的数量巨大时，计算量会非常大。为了优化KNN算法，可以采用kd-tree（k维树）。它可以在各个维度的空间内对较大量的点进行检索。</p>
<p>kd树是二叉树，构造过程简单来说就是不断用垂直于坐标轴的超平面将k维空间切分，构成许多超矩形区域。每个节点都对应一个超平面，这个超平面过节点中存储的点并且将k维空间分成两部分。</p>
<p>平衡kd树的构建是递归的，每次选择一个区间内的中位数大（后面解释）的点为根节点，然后中位数点左侧和右侧区间递归这个构建过程。直到区间大小为一。</p>
<p>中位数大的点就是指如果按照一定规则给点排序，排序后下标是中位数的那个点（中间的那个点）。构建kd树时给某区间点的排序规则是：位于第x层的节点比较第(x%k+1)维坐标的大小。比如：如果是构建整个树的根节点，则所有点都参与排序，比较的是它们的第一维的大小。位于中间的点就是根节点。</p>
<p>查询前n近的算法简单来说就是：用一个大小位n的大顶堆保存前n近的点。先从根节点出发找到给定点所在空间对应的kd树的叶子节点，并且在找这个点的时候把路途经过的点加入堆里。如果堆满了，而且新经过的点离待查询点更近一些，那就把堆顶的点去掉，并添加进这个点（注意新的点不一定还在堆顶）。这时候，堆中所有点都包含在以给定点为圆（球）心，以给定点到堆顶点为半径的圆（球）内。之后从叶子节点一层层返回，每到一层的一个父节点，就看另一个叶子节点所在的区域是不是与这个圆相交。如果相交说明这一侧可能有更近的点，那么就进入这一侧搜寻更近的点。</p>
<p>查询过程也可以用递归实现。判断与圆（球）相交的方法：圆（球）心到超平面的距离小于半径。</p>
<p>在网上看到的资料大多没有简单的代码，而且缺少注释。许多代码是复制一个开源C++库的，作为学习来说源代码的结构有点复杂，不太适合学习。<a href="https://en.wikipedia.org/wiki/K-d_tree">维基上</a>有更详细的解释和许多有用的学习资料连接，而且有python版的实现。</p>
<p>为了自己实现一个简单的kd树练练手，我从网上搜了一道<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4347">杭电OJ上的题</a>。对于KNN算法来说很实用的题目，要求就是给一些点，找离目标点前M近的点。只涉及树的建立和查询。</p>
<p>这道OJ题的代码：</p>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define MAX_DIM 5
#define DIS(X) ((X)*(X))

int n_dim;    //当前所比较的维度，分割面分割的维度

struct Point&#123;
    int coord[MAX_DIM]; //坐标
    Point *lft, *rgt;   //树的左右节点指针

    Point(int k)&#123;
        lft=rgt=NULL;
        for(int i=0; i&lt;k; i++)
            scanf(&quot;%d&quot;, &amp;coord[i]);
    &#125;

    Point()&#123;
        lft=rgt=NULL;
    &#125;

    inline bool operator&lt;(const Point &amp;b)const&#123;
        return coord[n_dim]&lt;b.coord[n_dim];
    &#125;
&#125;;

struct kdTree&#123;
    vector&lt;Point&gt; allp; //全体点
    priority_queue&lt;pair&lt;double, Point*&gt; &gt; *resultq; //查到的点
    int dim;    //空间的维度
    Point *root;    //树根指针

    kdTree(int n, int k)&#123;
        resultq=NULL;
        root=NULL;
        dim=k;
        for(int i=0; i&lt;n; i++)&#123;
            allp.push_back(Point(k));
        &#125;
        build(0, allp.size()-1, 0, root);
    &#125;

    void query(int m, Point &amp;p)&#123;
        Point res[20];
        resultq=new priority_queue&lt;pair&lt;double, Point*&gt; &gt;;
        queryInner(p, m, 0, root);
        //给出查询结果
        printf(&quot;the closest %d points are:\n&quot;, m);
        for(int n=0; !resultq-&gt;empty(); n++)&#123;
            res[n]=*(resultq-&gt;top().second);
            resultq-&gt;pop();
        &#125;
        for(int n=m-1; n&gt;=0;n--)&#123;
            for(int i=0; i&lt;dim; i++)
                printf(&quot;%d%c&quot;, res[n].coord[i], i==dim-1?&#39;\n&#39;:&#39; &#39;);
        &#125;
        delete resultq;
        resultq=NULL;
    &#125;

    void build(int l, int r, int dep, Point* &amp;rt)&#123;
        if(l&gt;r)return;
        int mid=(l+r)&gt;&gt;1;
        n_dim=dep%dim;  //存储分割面分割的是那个维度
        nth_element(allp.begin()+l, allp.begin()+mid, allp.begin()+r+1);

        rt=&amp;allp[mid];  //把空间的点接到树上
        build(l, mid-1, dep+1, rt-&gt;lft);
        build(mid+1, r, dep+1, rt-&gt;rgt);
    &#125;

    void queryInner(Point &amp;p, int m, int dep, Point *rt)&#123;
        if(rt==NULL)return;
        pair&lt;double, Point*&gt; tmp=make_pair(0.0, rt); //计算到被查点的距离，准备构建结果队列
        for(int i=0; i&lt;dim; i++)
            tmp.first+=DIS(rt-&gt;coord[i]-p.coord[i]);

        int now_dim=dep%dim;
        bool flg=false;
        Point *go=rt-&gt;lft, *go_another=rt-&gt;rgt;

        if(p.coord[now_dim]&gt;=rt-&gt;coord[now_dim])
            swap(go, go_another);   //go代表被查点所在的一侧
        if(go)
            queryInner(p, m, dep+1, go);
        if((int)resultq-&gt;size()&lt;m)&#123;
            resultq-&gt;push(tmp);
            flg=true;
            //查到的结果不够，一定向另一侧递归
        &#125;else&#123;
            if(tmp.first&lt;resultq-&gt;top().first)&#123;
                resultq-&gt;pop();
                resultq-&gt;push(tmp);
            &#125;//发现了更近的点
            /*待查询点与最远点形成的超球
                与分割空间的超平面相交，向不是所在的一侧递归
            */
            if(DIS(p.coord[now_dim] - rt-&gt;coord[now_dim]) &lt; resultq-&gt;top().first)
                flg=true;
        &#125;
        if(go_another &amp;&amp; flg)
            queryInner(p, m, dep+1, go_another);
    &#125;
    
&#125;;


int main()&#123;
    //freopen(&quot;1.txt&quot;, &quot;r&quot; ,stdin);
    int n, k;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k)!=EOF)&#123;
        kdTree *tree = new kdTree(n, k);
        int t;
        scanf(&quot;%d&quot;, &amp;t);
        while(t--)&#123;
            Point tmp=Point(k);
            int m;
            scanf(&quot;%d&quot;, &amp;m);
            tree-&gt;query(m, tmp);
        &#125;
        delete tree;
    &#125;
    return 0;
&#125;</code></pre>
<p>过段时间会再尝试一下用python写一个kd树。了解到kd树也是从《统计学习方法》上看到的。但是sklearn库还提供了ball-tree。据说比kd树还好。sklearn上现成的算法确实很高效，要远远比自己写的算法快，而且还提供了不少额外功能。但我估计可能是它底层有C/C++优化的原因。</p>
<p>网上搜OJ题解的时候看到所有的人都是开了四倍最大点数的定长数组写的，代码非常短。但其实根本没有必要（也许做比赛有必要吧，但我只求完成功能）。实际上，上面这份代码无论是消耗的内存空间还是执行时间都比开数组的方法小。</p>
<figure>
<img src="/img/kdtree/pic1.png" alt="" /><figcaption>pic1</figcaption>
</figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Linux Shellscript 安装网卡驱动</title>
    <url>/2014/07/15/linux-shellscript-wireless-card-compile/</url>
    <content><![CDATA[<p>每次升级内核都要重新编译网卡驱动，好麻烦（驱动是网上下的，BCM43142，系统自己没有）。刚好在学LINUX SHELLSCRIPT。写个SHELLSCRIPT，以后就成全自动安装了！</p>
<pre><code>#########################################################################
# File Name: NetcardCompiler.sh
# Author: ymy
# Created Time: Tue 15 Jul 2014 09:58:37 AM CST
#########################################################################
#!/bin/bash

cd ~/Compile/hybrid-v35_64-nodebug-pcoem-6_30_223_141
make clean
make API=WEXT
if [ -f &#39;wl.ko&#39; ] ; then
    cp wl.ko /lib/modules/`uname -r`/kernel/net/wireless
else
    echo &#39;Compile failed!&#39;
    exit
fi
modprobe lib80211
modprobe lib80211_crypt_tkip
insmod wl.ko
depmod -a
echo modprobe wl&gt;&gt; /etc/rc.local</code></pre>
<p>驱动的压缩包之前解压过了。如果要经常编译还是不要把解压后的文件夹删掉，最好把常用的软件解压到一个统一的地方。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux-shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Mathjax</title>
    <url>/2016/01/01/mathjax/</url>
    <content><![CDATA[<h2 id="博客使用mathjax"># 博客使用Mathjax</h2>
<p>update(2020-10-18): <a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/MATH.md">hexo+next主题参考这里</a></p>
<p><a href="https://introspelliam.github.io/2018/03/27/hexo/hexo%E4%BD%BF%E7%94%A8hexo-math%E6%8F%92%E4%BB%B6%E6%94%AF%E6%8C%81MathJax/">测试公式</a>：</p>
<p>$a = b + c $</p>
<p><span class="math display">\[\frac{\partial u}{\partial t}
= h^2 \left( \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} +
\frac{\partial^2 u}{\partial z^2}\right)\]</span></p>
<p>公式的inline插入方法外面套2个美元符号会居中，1个则不居中。就像上面的公式一样。</p>
]]></content>
      <categories>
        <category>开发环境配置</category>
      </categories>
      <tags>
        <tag>开发环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫自动生成程序</title>
    <url>/2014/07/20/maze-gen/</url>
    <content><![CDATA[<p>这学期开始时本来打算写个自动生成迷宫的程序。但当时水平所限，写不出来。假期这两天把这个想法付诸实施，现在想想这个程序挺有意思的。</p>
<p>程序和道理都非常简单，有些类似于走迷宫。</p>
<p>思路是这样：</p>
<p>1.首先假设迷宫场地是充满墙壁没有道路的。我们的工作其实就是把迷宫“挖”出来。不妨把开始时的迷宫看成一些小的“房间”，每个“房间”四面都被墙壁包围。画迷宫的过程实际就是从一个房间随机走到另一个房间，走的过程中把墙壁“挖掉”。定义一个类，这个类的每个对象代表迷宫里的一个格子，里面存放了这块墙壁或房间是否被挖过，以及它是否是一个“房间”。选好一个房间作为起点（我选的左上角），然后开始随机挖。</p>
<p>2.到达一个房间时判断四周房间的情况。按照四个方向判断。如果其中一个方向的隔壁房间挖过了，就不要把这个方向记录下来。如果四周都不能挖了，就一路退回之前能挖的地方。再次随机一个新方向，继续挖。（有点类似走迷宫的过程）</p>
<p>程序中记录道路用了C++STL里的栈。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#define M 25   //迷宫的规模
using namespace std;

class Grid&#123;
public:
    bool cell, dig;
&#125;;
//迷宫格子类型，记录了是否被挖过
Grid maze[M][M];
stack&lt;int&gt; row_s, col_s;
//用来存放路径的栈
void Init()&#123;
    for(int i=0; i&lt;M; i++)&#123;
        for(int j=0; j&lt;M; j++)&#123;
            maze[i][j].dig=false;
            if(i%2!=0 &amp;&amp; j%2!=0)
                maze[i][j].cell=true;
        &#125;
    &#125;
    row_s.push(1);    col_s.push(1);
    srand(time(0));
&#125;
//初始化迷宫格子
int DirRand()&#123;
    vector &lt;int&gt; dirlist;        //用来记录可选择的方向
    int result=0;
    int row=row_s.top(), col=col_s.top();
    //0 up, 1 down, 2 left, 3 right
    if(row-2&gt;0 &amp;&amp; !maze[row-2][col].dig) dirlist.push_back(0);
    if(row+2&lt;M-1 &amp;&amp; !maze[row+2][col].dig) dirlist.push_back(1);
    if(col-2&gt;0 &amp;&amp; !maze[row][col-2].dig) dirlist.push_back(2);
    if(col+2&lt;M-1 &amp;&amp; !maze[row][col+2].dig) dirlist.push_back(3);
    if(dirlist.size()==0) result=-1;
    else result=dirlist[rand()%((int)dirlist.size())];
    return result;
&#125;
//判断周围情况，没有可挖的格子时返回-1
void GenMaze()&#123;
    while(!row_s.empty() &amp;&amp; !col_s.empty())&#123;
        int dir=DirRand();
        int row=row_s.top(), col=col_s.top();
        if(dir!=-1)&#123;     //前进
            if(dir==0)&#123;
                maze[row-2][col].dig=maze[row-1][col].dig=true;
                row_s.push(row-2);  col_s.push(col);
            &#125;else if(dir==1)&#123;
                maze[row+2][col].dig=maze[row+1][col].dig=true;
                row_s.push(row+2);  col_s.push(col);
            &#125;else if(dir==2)&#123;
                maze[row][col-2].dig=maze[row][col-1].dig=true;
                row_s.push(row);    col_s.push(col-2);
            &#125;else if(dir==3)&#123;
                maze[row][col+2].dig=maze[row][col+1].dig=true;
                row_s.push(row);    col_s.push(col+2);
            &#125;
        &#125;else&#123;
            row_s.pop();    col_s.pop();        //后退
        &#125;
    &#125;
&#125;

void OutMaze()&#123;      //输出迷宫
    for(int i=0; i&lt;M; i++)&#123;
        for(int j=0; j&lt;M; j++)&#123;
            if(maze[i][j].cell || maze[i][j].dig)
            cout&lt;&lt;&quot;  &quot;;
            else cout&lt;&lt;&quot;##&quot;;        //为了保证对齐，墙壁和道路宽都是2个字符
        &#125;
        cout&lt;&lt;endl;
    &#125;
&#125;

int main()&#123;
    Init();
    GenMaze();
    OutMaze();
    return 0;
&#125;</code></pre>
<p>算法主要参考：<a href="http://en.wikipedia.org/wiki/Maze_generation_algorithm">http://en.wikipedia.org/wiki/Maze_generation_algorithm</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一个并查集问题的优化（CDOJ203）</title>
    <url>/2014/07/14/mfset-optimize-cdoj203/</url>
    <content><![CDATA[<p>一个多月前在成电OJ上看到一个并查集的问题，当时刚看完一些基础的数据结构，所以就试着做了。当然没有做出来。这题坑就在于：每组测试数据有10^5个，地图还是1000*1000的。挨着个每次都搜一遍不太可能。容易超时。</p>
<p>解决方法：潮水高度是递增的。所以想象一个退潮的过程，把每次退潮露出的岛屿记录下来，从最后最高的潮水高度算起。把露出的岛屿加入集合，每个测试数据对应的答案可以接着在下一组继续使用。</p>
<h1 id="islands">Islands</h1>
<blockquote>
<p>Deep in the Carribean, there is an island even stranger than the Monkey Island, dwelled by Horatio Torquemada Marley. Not only it has a rectangular shape, but is also divided into an n×m grid. Each grid field has a certain height. Unfortunately, the sea level started to raise and in year i, the level is i meters. Another strange feature of the island is that it is made of sponge, and the water can freely flow through it. Thus, a grid field whose height is at most the current sea level is considered flooded.Adjacent unflooded fields (i.e., sharing common edge) create unflooded areas. Sailors are interested in the number of unflooded areas in a given year.</p>
</blockquote>
<blockquote>
<p>An example of a 4×5 island is given below. Numbers denote the heights of respective fields in meters.Unflooded fields are darker; there are two unflooded areas in the first year and three areas in the second year.</p>
</blockquote>
<blockquote>
<p>Input</p>
</blockquote>
<blockquote>
<p>Multiple Test Cases</p>
</blockquote>
<blockquote>
<p>The input contains several test cases. The first line of the input contains a positive integer Z≤20,denoting the number of test cases. Then Z test cases follow, each conforming to the format described in section Single Instance Input. For each test case, your program has to write an output conforming to the format described in section Single Instance Output.</p>
</blockquote>
<blockquote>
<p>Single Instance Input</p>
</blockquote>
<blockquote>
<p>The first line contains two numbers n and m separated by a single space, the dimensions of the island, where 1≤n,m≤1000. Next n lines contain m integers from the range [1,10^9] separated by single spaces, denoting the heights of the respective fields. Next line contains an integer T (1≤T≤105). The last line contains T integers tj , separated by single spaces, such that 0≤t1≤t2≤⋯≤tT≤10^9</p>
</blockquote>
<blockquote>
<p>Output</p>
</blockquote>
<blockquote>
<p>Single Instance Output</p>
</blockquote>
<blockquote>
<p>Your program should output a single line consisting of T numbers rj , where rj is the number of unflooded areas in year tj . After every number ,you must output a single space</p>
</blockquote>
<blockquote>
<p>Sample Input</p>
</blockquote>
<blockquote>
<p>1</p>
</blockquote>
<blockquote>
<p>4 5</p>
</blockquote>
<blockquote>
<p>1 2 3 3 1</p>
</blockquote>
<blockquote>
<p>1 3 2 2 1</p>
</blockquote>
<blockquote>
<p>2 1 3 4 3</p>
</blockquote>
<blockquote>
<p>1 2 2 2 2</p>
</blockquote>
<blockquote>
<p>5</p>
</blockquote>
<blockquote>
<p>1 2 3 4 5</p>
</blockquote>
<blockquote>
<p>Sample Output</p>
</blockquote>
<blockquote>
<p>2 3 1 0 0</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
class Field&#123;
public:
    int height, father;
    bool under;
&#125;;

int Z;  int row, col, T;
int res[100000];
vector&lt;int&gt; height_list[100000];
vector&lt;int&gt; t;
int i,j,result,temp;
Field field[1000][1000];
int Father(int a, int b)&#123;
    if (field[a][b].father!=a*col+b)
        field[a][b].father=Father(field[a][b].father/col, field[a][b].father%col);
    return field[a][b].father;
&#125;

void Merge(int a, int b, int c, int d)&#123;
    int f1, f2, x, y;
    f1=Father(a, b);    f2=Father(c, d);
    if(f1==f2) return;
    else&#123;
        result--;
        x=field[a][b].father/col;
        y=field[a][b].father%col;
        field[x][y].father=f2;
    &#125;
&#125;

void Check(int r, int c)&#123;
    if (r+1&lt;row &amp;&amp; !field[r+1][c].under) &#123;Merge(r, c, r+1, c); &#125;
    if (r-1&gt;=0 &amp;&amp; !field[r-1][c].under) &#123;Merge(r, c, r-1, c); &#125;
    if (c+1&lt;col &amp;&amp; !field[r][c+1].under) &#123;Merge(r, c, r, c+1); &#125;
    if (c-1&gt;=0 &amp;&amp; !field[r][c-1].under) &#123;Merge(r, c, r, c-1); &#125;
&#125;

void Solve()&#123;
    int x, y, m, n;
    result=0;
    for(m=t.size()-1; m&gt;=0; m--)&#123;
        for(n=height_list[m].size()-1; n&gt;=0; n--)&#123;
            x=height_list[m][n]/col;   y=height_list[m][n]%col;
            field[x][y].under=false;
            result++;   Check(x, y);
        &#125;
        res[m]=result;
    &#125;
&#125;

int main()&#123;
    scanf(&quot;%d&quot;, &amp;Z);
    while(Z--)&#123;
        result=0;
        t.clear();
        for (i=0; i&lt;100000; i++) height_list[i].clear();

        scanf(&quot;%d%d&quot;, &amp;row, &amp;col);
        for(i=0; i&lt;row; i++)&#123;
            for(j=0; j&lt;col; j++)&#123;
                scanf(&quot;%d&quot;, &amp;field[i][j].height);
                field[i][j].under=true;
                field[i][j].father=i*col+j;
            &#125;
        &#125;

        scanf(&quot;%d&quot;, &amp;T);
        for(i=0; i&lt;T; i++)&#123;
            scanf(&quot;%d&quot;, &amp;temp);
            t.push_back(temp);
        &#125;

        for(i=0; i&lt;row; i++)&#123;
            for(j=0; j&lt;col; j++)&#123;
                temp=lower_bound(t.begin(), t.end(), field[i][j].height)-t.begin();
                if(temp&gt;0) height_list[temp-1].push_back(i*col+j);
            &#125;
        &#125;
        Solve();
        for(i=0; i&lt;(int)t.size(); i++) printf(&quot;%d &quot;, res[i]);
        printf(&quot;\n&quot;);
    &#125;
    return 0;
&#125;</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis 从零基础到增删改查数据库</title>
    <url>/2014/07/27/mybatis-0toadcq/</url>
    <content><![CDATA[<p>本文是mybatis框架一个初步的入门总结，最全的最好的资料应该参考<a href="http://mybatis.github.io/mybatis-3/zh/index.html">这个</a></p>
<p>本文在Eclipse下搭建一个小程序可以测试mybatis对mysql数据库进行增删改查这几个基本功能。</p>
<p>1.首先建立数据库，我建立的数据库叫test，编码是UTF-8，里面有两张表，它们是这样的：</p>
<figure>
<img src="/img/mybatis_0toadcq/1.png" alt="" /><figcaption>pic1</figcaption>
</figure>
<p>两张表的数据我填的是这样的，当然可以随便填，不过最好在person中有1个以上name相同的，后面会用到：</p>
<figure>
<img src="/img/mybatis_0toadcq/2.png" alt="" /><figcaption>pic2</figcaption>
</figure>
<p>2.在ECLIPISE下建立DYNAMIC WEB PROJECT，别忘了在BUILD PATH下加入mybatis和mysql的jar包。这个工程的布局是这样的：</p>
<p>文件和类的用途后面解释</p>
<figure>
<img src="/img/mybatis_0toadcq/3.png" alt="" /><figcaption>pic3</figcaption>
</figure>
<p>Main里面有程序的static void main函数。Test类封装了测试mybatis框架功能的函数。xml都是框架的配置文件。Person与Student是DTO数据传输对象。两个Mapper类都是接口类，用途后面讲。</p>
<p>3.配置Configuration.xml。在src文件夹下先建立这个文件。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;typeAliases&gt; 
        &lt;typeAlias alias=&quot;Person&quot; type=&quot;com.ymy.mybatis.model.Person&quot;/&gt; 
        &lt;typeAlias alias=&quot;Student&quot; type=&quot;com.ymy.mybatis.model.Student&quot;/&gt; 
        &lt;!-- short name of java classes --&gt;
    &lt;/typeAliases&gt; 

    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!--
            choose any name for default and id
              --&gt;
        &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/test&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;31415926&quot;/&gt;
            &lt;property name=&quot;driver.encoding&quot; value=&quot;UTF8&quot;/&gt;
            &lt;!--property name=&quot;PROPERTY NAME&quot; value=&quot;$&#123;var name&#125;&quot;/--&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/ymy/mybatis/model/Person.xml&quot;/&gt;
        &lt;mapper resource=&quot;com/ymy/mybatis/model/Student.xml&quot;/&gt;
        &lt;!-- xml of mapper class --&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre>
<p>标签解释：</p>
<pre><code>&lt;typeAliases&gt; 定义的是别名，全名是type里的一大串，起个别名减少了后面的书写量。

&lt;environments&gt;和&lt;environment&gt;配置了数据库的信息，一个environments下可以配多个environment来访问多个数据库，这超出了本文讨论范围。这个文章：http://zhangbo-peipei-163-com.iteye.com/blog/2052924讲了多数据源配置。

&lt;property name&gt;和value改成自己的数据库的就行了

&lt;mappers&gt;下定义多个&lt;mapper&gt;每个mapper对应一个DTO类型，以及它们对应的数据库操作。mapper resource后面是对应DTO的xml文件的实际位置。</code></pre>
<p>3.建立DTO类Student和Person。</p>
<p>Student类:</p>
<pre><code>package com.ymy.mybatis.model;

public class Student &#123;
    private int id;
    private String name;
    private int score;

    public Student() &#123;
    &#125;

    public int getID() &#123;
        return id;
    &#125;

    public void setID(int id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getScore() &#123;
        return score;
    &#125;

    public void setScore(int score) &#123;
        this.score = score;
    &#125;
&#125;</code></pre>
<p>Person类：</p>
<pre><code>package com.ymy.mybatis.model;

public class Person &#123;
    private int id;
    private String name;
    private int age;
    private String address;

    public Person(String name, int age, String address) &#123;
        this.name = name;
        this.age = age;
        this.address = address;
    &#125;

    public Person(int id, String name, int age, String address) &#123;
        this.id = id;
        this.name = name;
        this.age = age;
        this.address = address;
    &#125;

    public Person() &#123;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getAddress() &#123;
        return address;
    &#125;

    public void setUserAddress(String userAddress) &#123;
        this.address = userAddress;
    &#125;
&#125;</code></pre>
<p>4.配置Student.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; 
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.ymy.mybatis.model.StudentMapper&quot;&gt;
  &lt;select id=&quot;selectStudentByID&quot; parameterType=&quot;int&quot; resultType=&quot;Student&quot;&gt;
     select * from student where id = #&#123;id&#125;
 &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
<p>解释：&lt; mapper namespace &gt;那句，相当于在命名空间com.ymy.mybatis.model.StudentMapper下定义了一个叫selectStudentByID的语句，它接收的参数类型（parameterType）为int，返回类型为Student。到后面我们定义了接口类StudentMapper，mybatis就会把接口中的函数和xml中的定义绑定。&lt; select &gt;标签说明这是查询类型的操作。</p>
<p>接口类StudentMapper：</p>
<pre><code>package com.ymy.mybatis.model;

public interface StudentMapper &#123;
    public Student selectStudentByID(int id);
&#125;</code></pre>
<p>配置Person.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; 
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.ymy.mybatis.model.PersonMapper&quot;&gt;
     &lt;resultMap id=&quot;personResultMap&quot; type=&quot;Person&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
             &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;
             &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;
             &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;selectPersonByID&quot; parameterType=&quot;int&quot; resultType=&quot;Person&quot;&gt;
         select * from person where id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;select id=&quot;selectPersonByName&quot; parameterType=&quot;String&quot; resultMap=&quot;personResultMap&quot;&gt;
         select * from person where name = #&#123;name&#125;
    &lt;/select&gt;

    &lt;select id=&quot;lastInsertId&quot; resultType=&quot;int&quot;&gt;
          select last_insert_id()
    &lt;/select&gt;

    &lt;insert id=&quot;addPerson&quot; parameterType=&quot;Person&quot;&gt;
            insert into person (id,name,age,address)
            values (NULL,#&#123;name&#125;,#&#123;age&#125;,#&#123;address&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;updatePerson&quot; parameterType=&quot;Person&quot;&gt;
            update person set
            name = #&#123;name&#125;,
            age = #&#123;age&#125;,
            address= #&#123;address&#125;
            where id = #&#123;id&#125;
    &lt;/update&gt;

    &lt;delete id=&quot;deletePerson&quot; parameterType=&quot;int&quot;&gt;
         delete from person where id = #&#123;id&#125;
    &lt;/delete&gt;
&lt;/mapper&gt;</code></pre>
<p>看sql语句就知道都是干啥的了，增删改查已经全了。重点是selectPersonByName。数据库里有重名的人，所以会查询到多个人。这时返回类型标签成了resultMap。值为personResultMap。文件最前面定义了personResultMap。result里面property是DTO里变量的名称。column和数据库里的名称对应。</p>
<p>接口类PersonMapper:</p>
<pre><code>package com.ymy.mybatis.model;

import java.util.List;

public interface PersonMapper &#123;
    public Person selectPersonByID(int id);
    public List&lt;Person&gt; selectPersonByName(String name);
    
    public void addPerson(Person person);
    public void deletePerson(int id);
    public void updatePerson(Person person);
    public int lastInsertId();
&#125;</code></pre>
<p>5.写测试代码：</p>
<p>Test类：</p>
<pre><code>package com.ymy.mybatis.test;

import java.io.*;
import java.util.*;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import com.ymy.mybatis.model.*;

public class Test &#123;
    private static SqlSessionFactory sqlSessionFactory;
    // it should be static
    // every thread should have its own SqlSession instance
    private static Reader reader;
    static &#123;
        try &#123;
            reader = Resources.getResourceAsReader(&quot;Configuration.xml&quot;);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
            // every database should have its own SqlSessionFactory
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public void getPersonList(String userName) &#123;
        SqlSession session = sqlSessionFactory.openSession();
        try &#123;
            PersonMapper mapper = session.getMapper(PersonMapper.class);
            List&lt;Person&gt; people = mapper.selectPersonByName(userName);
            for (Person person : people) &#123;
                System.out.print(&quot;Name: &quot; + person.getName() + &quot;\t&quot;);
                System.out.print(&quot;Age: &quot; + person.getAge() + &quot;\t&quot;);
                System.out.println(&quot;Addr: &quot; + person.getAddress());
            &#125;
        &#125; finally &#123;
            session.close();
        &#125;
    &#125;

    public void addPerson() &#123;
        @SuppressWarnings(&quot;resource&quot;)
        Scanner inputer = new Scanner(System.in);
        System.out.println(&quot;Input a person&#39;s name age and address&quot;);
        String name = inputer.next();
        int age = inputer.nextInt();
        String address = inputer.next();

        Person newPerson = new Person(name, age, address);
        SqlSession session = sqlSessionFactory.openSession();
        try &#123;
            PersonMapper mapper = session.getMapper(PersonMapper.class);
            mapper.addPerson(newPerson);
            int last_id = mapper.lastInsertId();
            System.out.println(&quot;Insert id = &quot; + last_id);
            session.commit();
        &#125; finally &#123;
            session.close();
        &#125;
    &#125;
    
    public void updatePerson() &#123;
        @SuppressWarnings(&quot;resource&quot;)
        Scanner inputer = new Scanner(System.in);
        System.out.println(&quot;Input a person&#39;s id, name, age and address&quot;);
        int id = inputer.nextInt();
        String name = inputer.next();
        int age = inputer.nextInt();
        String address = inputer.next();

        Person person = new Person(id, name, age, address);
        SqlSession session = sqlSessionFactory.openSession();
        try &#123;
            PersonMapper mapper = session.getMapper(PersonMapper.class);
            mapper.updatePerson(person);
            session.commit();
            System.out.println(&quot;OK!&quot;);
        &#125; finally &#123;
            session.close();
        &#125;
    &#125;

    public void deletePerson() &#123;
        @SuppressWarnings(&quot;resource&quot;)
        Scanner inputer = new Scanner(System.in);
        System.out.println(&quot;Input an id to delete:&quot;);
        int id = inputer.nextInt();

        SqlSession session = sqlSessionFactory.openSession();
        try &#123;
            PersonMapper mapper = session.getMapper(PersonMapper.class);
            mapper.deletePerson(id);
            session.commit();
        &#125; finally &#123;
            session.close();
        &#125;
    &#125;
    
    public void selectPersonById()&#123;
        @SuppressWarnings(&quot;resource&quot;)
        Scanner inputer = new Scanner(System.in);
        System.out.println(&quot;Input an id to select:&quot;);
        int id = inputer.nextInt();
        
        SqlSession session = sqlSessionFactory.openSession();
        try &#123;
            PersonMapper mapper = session.getMapper(PersonMapper.class);
            Person person = mapper.selectPersonByID(id);
            System.out.print(&quot;Name: &quot; + person.getName() + &quot;\t&quot;);
            System.out.print(&quot;Age: &quot; + person.getAge() + &quot;\t&quot;);
            System.out.println(&quot;Addr: &quot; + person.getAddress());
        &#125; finally &#123;
            session.close();
        &#125;
    &#125;
    
    public void selectStudentById()&#123;
        @SuppressWarnings(&quot;resource&quot;)
        Scanner inputer = new Scanner(System.in);
        System.out.println(&quot;Input an student id to select:&quot;);
        int id = inputer.nextInt();
        
        SqlSession session = sqlSessionFactory.openSession();
        try &#123;
            StudentMapper mapper = session.getMapper(StudentMapper.class);
            Student student = mapper.selectStudentByID(id);
            System.out.print(&quot;Name: &quot; + student.getName() + &quot;\t&quot;);
            System.out.print(&quot;ID: &quot; + student.getID() + &quot;\t&quot;);
            System.out.println(&quot;Score: &quot; + student.getScore());
        &#125; finally &#123;
            session.close();
        &#125;
    &#125;
    
&#125;</code></pre>
<p>解释：我们通过SqlSession类的对象获取映射（使用getMapper方法），通过映射调用Student和Person接口类里的函数。SqlSession参与数据库的管理事务。当执行了修改数据库内容的语句后调用commit()方法讲更改的内容写入数据库。完成后及时关闭SqlSession对象，调用close()方法。</p>
<p>最后写Main类，然后运行程序：</p>
<pre><code>package com.ymy.mybatis.test;

public class Main &#123;
    public static void main(String[] args) &#123;
        Test t1 = new Test();
        t1.selectPersonById();
        t1.getPersonList(&quot;Bill&quot;);// find Bill
        t1.addPerson();
        t1.deletePerson();
        t1.updatePerson();
        
        t1.selectStudentById();
    &#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>想写出高质量的博客</title>
    <url>/2020/08/09/new-blog2020/</url>
    <content><![CDATA[<p>很长时间没有写博客了。工作三年期间学到不少东西，作为一个新人来说这可能是都会经历的。但写在博客上，能为他人带来多大的启发呢？毕竟不是学生了，如果还是写xxx教程，记录一些感想（年轻人都有的那种），无非是增加了整个互联网上一些无用的信息罢了：）</p>
<p>前段时间一直在思考“博客写什么”这个问题。甚至上个月把原来的博客删掉了，但是今天又把博客恢复了过来。某种意义上，这是一种完美主义者的一次“发病”。但是这种思考是值得的，这个问题目前有了解答，至于对不对就要先用实践检验下了。</p>
<h1 id="写什么">写什么</h1>
<p>想了下没什么可写的原因，大概有以下几个： 1. 工作中见到的牛逼的东西多了，以至于觉得自己想写的东西没那么高端。 2. 有些能写的东西是公司的项目，不一定适合发在博客这种外部平台上。 3. 个人学习和总结，有更好的方式（思维导图，云笔记，甚至写到本上），写博客性价比不太高。 4. 很多东西写下来只对自己有用，别人懒得看。</p>
<h1 id="怎么改变">怎么改变</h1>
<ol type="1">
<li>自己觉得最牛逼的项目，如果是开源的，就争取主动参加进去。另外有意识的每次拔高一下写的内容。</li>
<li>写点自己学的新东西和踩的坑，多折腾就有更多的内容写。</li>
<li>不要指望写博客提高自己，而是要用博客提高影响力和督促自己进步。</li>
<li>写点技术外的东西，能让大家开心下也挺好。</li>
</ol>
<h1 id="实施计划">实施计划</h1>
<ol type="1">
<li>先找找看看有哪些牛逼项目。</li>
<li>把前段时间学的新东西拿出来写写。</li>
<li>在微信朋友圈和qq空间里打一波广告。</li>
<li>写一些非技术文章，做个有趣的人。</li>
</ol>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>质数表的生成以及质数的判断</title>
    <url>/2016/01/08/primenumbers/</url>
    <content><![CDATA[<p>最近看了一个问题，涉及到质数的判断。以前没有留意过这方面的方法。但是特意找了下资料发现自己解决这个问题的方法还是很笨的，网上有许多更好的方法。这里做个简单的总结。</p>
<h1 id="生成质数表">生成质数表</h1>
<p>首先最笨的办法是生成一个表来判断。以前上离散数学的时候讲过可以用筛法求这个表。把这个表先算出来显然是很划算的。但是，生成这个表也有好和不好的方法。</p>
<h2 id="eratosthenes筛法">Eratosthenes筛法</h2>
<p>给出要筛数值的范围<span class="math inline">\(\sqrt(n)\)</span>，然后把范围内2的倍数划去，然后找到第一个没被划去的数。再把这个数的倍数划去，然后再找第一个没被划去的数，如此重复。。。</p>
<h2 id="欧拉筛法">欧拉筛法</h2>
<p>这个方法比上一个筛法要快很多。原因是上一个算法会重复筛某些数（尽管标记为已经筛除，但是还是要判断）。比如说6会被2和3筛去。这个方法主要思想就是每个合数只被最小的质因数筛掉。</p>
<pre><code>void gen()&#123;
    for(int i=2; i&lt;=N; i++)&#123;
        if(!check[i])&#123;//没被划去的i，是质数
            prime[total++]=i;
            isPrime[i] = true;
        &#125;
        for(int j=0; j&lt;total; j++)&#123;
            int t = i*prime[j];//i和之前所有的质数相乘
            if(t&gt;N)break;
            check[t] = true;//筛掉
            if(i%prime[j]==0)break;
            //保证了每个合数只会被它的最小素因子筛掉
        &#125;
    &#125;//end enum
&#125;</code></pre>
<p>上面代码prime是保存质数的，而isPrime是一个标记数组。查表判断就靠isPrime了，N是范围。</p>
<h2 id="只生成一部分质数表">只生成一部分质数表</h2>
<p>上面的方法尽管高效但是浪费空间，而且要判断的数字比较大的时候，事先要准备一个比较大的表，计算起来也是比较费事的。折衷的方法是生成一部分表。表内的最大质数为可能检测的最大数的平方根。这样小于平方根的直接判断，大于平方根的可以从表头循环检查能否整除待检测的数。</p>
<h1 id="拉宾-米勒测试">拉宾-米勒测试</h1>
<p>这种方法不用生成表。但是给出的结果不一定准确。多次测试的话，可以减小误判的概率。详细的介绍见<a href="http://baike.baidu.com/link?url=fsFu6ZZ3HCIqSvy2a151aPV2_F2C5l2c0eoZl5w9pZ5FGy0oTjWTEZ1KoADySIPBxW_-POySLExSPo6ccGcnzq">链接</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>随机排列产生</title>
    <url>/2016/02/06/randomgener/</url>
    <content><![CDATA[<p>这学期选上了人工智能这门选修课，最后课程设计里大量用到了随机排列功能（打乱数据用的）。然而自己从来没实现过这类功能。昨天晚上偶然想起这个遗憾的事，于是自己想到一个实现，感觉很好理解也好写，在这里写一下。</p>
<p>道理很简单，只有3步，是个迭代过程。设要打乱的数据有n条。</p>
<ol type="1">
<li><p>判断n是否小于1。如果小于1退出。</p></li>
<li><p>生成1个0到n-1的随机数t，作为下标。</p></li>
<li><p>交换最后一条记录和第t条记录。n=n-1。回到第一步。</p></li>
</ol>
<p>代码（C++）：</p>
<pre><code>void RandomPermu(int a[], int n)&#123;
    while(n&gt;0)&#123;
        swap(a[rand()%n], a[n-1]);
        n--;
    &#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>偶然想起</category>
      </categories>
      <tags>
        <tag>偶然想起</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯实习面试经历总结和记录</title>
    <url>/2016/05/13/tencent-intern-interview/</url>
    <content><![CDATA[<p>之前因为学校考试时间原因拒绝了阿里巴巴的实习机会。几天后腾讯那边通知笔试过了，要去面试。腾讯的面试经历也是相当宝贵的经历，因为是第一次参加现场的面试，所以记录一下（4月底面的，问的问题可能不止这些，时间久记不住所有问题）。</p>
<h1 id="一面">一面</h1>
<p>一面面试问了一些基础问题，因为投的是后台开发，问了很多网络方面的问题，但是都十分基础。比如：HTTP协议是TCP还是UDP之上的？讲一下HTTPS协议。对Linux套接字编程了解如何，发送和读取数据有哪些方法（我不知道什么意思，答的是那几个API:read/write, send/recv, sento/recvfrom，然后扯了一下udp的发送和接受）。阻塞和非阻塞通信的区别（中间有个概念搞错了，设置超时也是属于阻塞的）？还有套接字怎么关闭的（四次挥手），为什么有等待时延，套接字关闭后还能收数据么（没答出来）？算法问题比较简单：从两个链表中找出重复数字。我一开始用哈希表，就着优化哈希表扯了半天，后经提醒换用位图法，用01位标记数字是否出现。不过答题前我问面试官数字范围，他说int范围。我觉得这样用位图的话空间开销很大，如果链表不长还是哈希好点，但是我猜这是正确答案吧，所以没用开始没用位图的理由我就没说。最后问C和C++，static关键字的作用（忘了答在C++类里的作用了），static变量在内存的布局。没问项目经历和参加的比赛。一面问了二十多分钟。</p>
<p>可能是早上六点多就从学校赶到市区面试的原因，平时睡眠时间本来就不是很多，一早起脑袋有点晕。好多会的问题没回答好。。。答题前一定要想好再说，要点要说全。。。</p>
<h1 id="二面">二面</h1>
<p>二面还是没怎么问项目。。。问了比赛：介绍数学建模是什么比赛，你负责干什么？我就介绍了一下，然后讲了下15年国赛题（作了个死，说这个比赛和计算机关系不大。。。），我说我负责编程辅助写作，LaTex比较熟。然后问最近在干什么，我说学校让组队做个大课设，我和另外两个同学写一套ftp服务器和客户端，我负责整个项目。之后就是让深入介绍服务器的架构，以及你们怎么学习、了解、实现ftp协议的。我大概讲了一下我们怎么用ftp和FileZilla与vsftpd通信看报文，怎么看RFC文档。我们写的服务器是如何用单进程和select实现并发。大概讲了select在我们的服务器里怎么用的。中途被问知道epoll不？我说知道，但是面试官没继续问，让我接着讲服务器。又问为什么不用多线程，我说另外两个同学不熟悉pthread（糊涂了，应该讲讲单进程并发的好处）。。。然后就是问整个服务器性能怎么优化，第一反应什么都没想到。。。经提醒后回答了可以根据文件大小情况预读一部分文件到内存里，这样就不会因为fread的buffer太小反复读硬盘（服务器五一节的时候写好了，没加这个功能，传了个上G的文件，感觉可能有必要加这个功能）。中间扯优化的时候不知道怎么说起加锁上了，于是说了pthread_mutex的用法，又说了pthread_rwlock。最后问了算法，问1亿条短信中怎么找重复出现频率最高的100条短信（也就是这100条其实内容一样）。面试官挺好的，说这个问题可以多想想，没有标准答案，想你觉得最好的方法。最后我说的是数据随机分到多台机器上，每台机器找用hash找100个重复率最高的数据，然后直接把统计结果汇总一下，在一台机器上加起来，汇总后出现最多的100个就是答案了。面试完了想想貌似不对，如果某条前100的短信被比较“平均”地分发到所有机器上，那么可能它不会进入这些机器的前100。。。所以应该就直接每个返回这个机器上所有的统计结果，最后汇总。虽然麻烦，但不会错。最后一个问题是如何存储和查询一个短信是否存在于这1亿条短信中。开始直接说的哈希，然后觉得太low了。。。又说了如果短信内容有由多片段重复组成的，可以采用类似字典树的方法，还能省些空间，然后画了一下示意图。现在想想直接哈希肯定不行的，因为数据量太大（后来知道了一个东西叫Hash Tree，感觉用来解决这个问题或许可行）。二面大概半小时。</p>
<p>感觉就是最后的开放性问题回答不太好。平时这类问题没看过，学校课程和项目中也不出现这类问题，是个短板。问最近干什么居然说的做学校课设也是low爆了，应该说在学些什么技术之类的。。。不过这也是实话是说吧，这学期专业必修课开太多了，光是作业和实验就挺忙了，加上找实习，确实就没学新东西。</p>
<h1 id="hr面">HR面</h1>
<p>HR面主要就是问问爱好，家在哪里，有女朋友么，聊点学校学习的事情，喜欢哪个城市。可能因为以前在高考人口大省上学，又聊了学校和为什么学计算机。HR居然还问了简历上的比赛经历，这个我很意外。HR挺友好，知道我们学校在郊区，进来面试时候给了我一瓶宾馆的矿泉水。</p>
<p>HR面没什么感觉。。。不知道刷人的标准是什么，我猜测是主要依据是前两面表现，另外看性格和交流能力吧。</p>
<p>最后过了一周，在五一前通知面试过了，分配到了TEG做后台开发。也总算是告一段落了。运气不错的是我认识的另外两个人也过了面试。</p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>两个线段树的基础问题</title>
    <url>/2014/07/14/two-segtree-basic-problems/</url>
    <content><![CDATA[<p>两个问题，代表线段树中最基础的两类：1.更新数组里某个值然后查询。2.统一更新数组中一段区间的值然后查询。放假回来这两天也就看到了这里：）</p>
<p>为什么要学习线段树（个人之见）：1.如果有上万甚至更多的数据反复查找并更新，用这个数据结构就比较高效了。2.高级的数据结构和算法多学些没坏处，尤其大一大二需要注重基础。3.想考这个<a href="http://cspro.ccf.org.cn/lead/info.do?__action=info_view&amp;catalog=notice&amp;id=hsyfsb9v-8yx&amp;__forward=true">证书</a>的话需要学：）</p>
<p>第一类问题:</p>
<blockquote>
<p>成电OJ 838 母仪天下</p>
</blockquote>
<blockquote>
<p>富庶的建业城中，有一条格格不入的长街，名曰跳蚤街，被战争所致的孤儿，聚集于此。全国的经济都在为战争服务之时，也无人顾得了这里了。</p>
</blockquote>
<blockquote>
<p>除了两位夫人。</p>
</blockquote>
<blockquote>
<p>大乔小乔每天都会带着一些食物来到跳蚤街，分给某一位孩子。为了避免分配不均，她们时常会询问一个区域内食物的总量，然后进行调整以保证每个孩子都有足够的食物。</p>
</blockquote>
<blockquote>
<p>Input</p>
</blockquote>
<blockquote>
<p>第一行两个整数n，m，表示跳蚤街住着n户孩子，大乔小乔一共分发或询问了m次。</p>
</blockquote>
<blockquote>
<p>第二行n个整数，第i个数ai表示第i户孩子已有ai的食物。</p>
</blockquote>
<blockquote>
<p>接下来m行，每行开始先读入一个整数si，指明这是一次询问还是一次分发。</p>
</blockquote>
<blockquote>
<p>si=0，表明这是一次询问，然后读入两个整数li,ri，表示询问[li，ri]区间中的孩子们一共有多少食物。</p>
</blockquote>
<blockquote>
<p>si=1，表明这是一次分发，然后读入两个整数xi,wi，表示对第xi户孩子分发了wi的食物。</p>
</blockquote>
<blockquote>
<p>1≤n,m≤100000,0≤ai≤100000,1≤xi≤n,0≤wi≤10000,1≤li≤ri≤n</p>
</blockquote>
<blockquote>
<p>Output</p>
</blockquote>
<blockquote>
<p>有多少询问就输出多少行，每行输出一个整数，作为对该询问的回答。</p>
</blockquote>
<blockquote>
<p>Sample Input</p>
</blockquote>
<blockquote>
<p>5 4</p>
</blockquote>
<blockquote>
<p>1 2 3 4 5</p>
</blockquote>
<blockquote>
<p>1 2 3</p>
</blockquote>
<blockquote>
<p>0 2 4</p>
</blockquote>
<blockquote>
<p>1 4 1</p>
</blockquote>
<blockquote>
<p>0 1 5</p>
</blockquote>
<blockquote>
<p>Sample Output</p>
</blockquote>
<blockquote>
<p>12</p>
</blockquote>
<blockquote>
<p>19</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

typedef struct&#123;
    int l,r;
    int sum;
&#125;SegTree;

int n,m,i,j,s;

void Build(SegTree trees[], int id, int l, int r)&#123;
    trees[id].l=l; trees[id].r=r;
    if (l==r)&#123;
        trees[id].sum=0;
    &#125;else&#123;
        int mid=(l+r)/2;
        Build(trees, 1+id*2, l, mid);
        Build(trees, id*2+2, mid+1, r);
        trees[id].sum=trees[id*2+2].sum+trees[id*2+1].sum;
    &#125;
&#125;

void Update(SegTree trees[], int id, int pos, int val)&#123;
    if (trees[id].l==trees[id].r)&#123;
        trees[id].sum=val;
    &#125;else&#123;
        int mid=(trees[id].l+trees[id].r)/2;
        if (pos&lt;=mid) Update(trees, id*2+1, pos, val);
        else Update(trees, id*2+2, pos, val);
        trees[id].sum=trees[id*2+2].sum+trees[id*2+1].sum;
    &#125;
&#125;

int Query(SegTree trees[], int id, int l, int r)&#123;
    if (trees[id].l==l &amp;&amp; trees[id].r==r)
        return trees[id].sum;
    else&#123;
        int mid=(trees[id].l+trees[id].r)/2;
        if(r&lt;=mid) return Query(trees, id*2+1, l, r);
        else if(l&gt;mid) return Query(trees, id*2+2, l, r);
        else return Query(trees, id*2+1, l, mid)+Query(trees, id*2+2, mid+1, r);
    &#125;
&#125;

int main()&#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int a[n];
    SegTree *tree=new SegTree[4*n];
    Build(tree, 0, 0, n-1);
    for(i=0; i&lt;n; i++)&#123;
        scanf(&quot;%d&quot;, &amp;a[i]);
        Update(tree, 0, i, a[i]);
    &#125;
    for(i=0; i&lt;m; i++)&#123;
        int q, ll_x, rr_w;
        scanf(&quot;%d%d%d&quot;, &amp;s, &amp;ll_x, &amp;rr_w);
        if(s==0)&#123;
            q=Query(tree, 0, ll_x-1, rr_w-1);
            printf(&quot;%d\n&quot;, q);
        &#125;else&#123;
            q=Query(tree, 0, ll_x-1, ll_x-1);
            Update(tree, 0, ll_x-1, rr_w+q );
        &#125;
    &#125;
    return 0;
&#125;</code></pre>
<p>我的数组下标是从0开始的。所以线段树的写法可能看上去和网上一些模板和伪代码不太一样。</p>
<p>第二类问题：</p>
<blockquote>
<p>成电OJ 839 东风不与周郎便</p>
</blockquote>
<blockquote>
<p>“揽二乔于东南兮，乐朝夕之与共”</p>
</blockquote>
<blockquote>
<p>一首铜雀台赋，将愤怒与恐惧散播在了孙吴大军之中。</p>
</blockquote>
<blockquote>
<p>对抗曹军，万事俱备，只欠东风。</p>
</blockquote>
<blockquote>
<p>现在已经找到n个风眼，这些风眼的东风有强有弱，诸葛亮说他每次祈风都能够将一段风眼的东风增强，但需人去帮他布阵。同时他需要时刻掌控风眼的状况，以确定下一步的计划，所以还需要知道一段风眼的强度之和。</p>
</blockquote>
<blockquote>
<p>借东风，此乃逆天之术，施术者会折阳寿不说，布阵者更是会受十倍之伤。</p>
</blockquote>
<blockquote>
<p>“何人能当此任？”</p>
</blockquote>
<blockquote>
<p>“在下愿往，大都督。”</p>
</blockquote>
<blockquote>
<p>“你是？”</p>
</blockquote>
<blockquote>
<p>“在下一无名小卒，来自跳蚤街。”</p>
</blockquote>
<blockquote>
<p>Input</p>
</blockquote>
<blockquote>
<p>第一行两个整数n，m，表示有n个风眼，诸葛亮一共祈风或询问了m次。</p>
</blockquote>
<blockquote>
<p>第二行n个整数，第i个数ai表示第i个风眼已有东风的强度。</p>
</blockquote>
<blockquote>
<p>接下来m行，每行开始先读入一个整数si，指明这是一次询问还是一次祈风。</p>
</blockquote>
<blockquote>
<p>si=0，表明这是一次询问，然后读入两个整数li,ri，表示询问[li，ri]区间中风眼的东风强度之和。</p>
</blockquote>
<blockquote>
<p>si=1，表明这是一次祈风，然后读入三个整数li,ri,wi，表示把[li，ri]区间中每个风眼的东风强度提升wi。</p>
</blockquote>
<blockquote>
<p>1≤n,m≤100000,0≤ai≤10000,0≤wi≤10000,1≤li≤ri≤n</p>
</blockquote>
<blockquote>
<p>Output 有多少询问就输出多少行，每行输出一个整数，作为对该询问的回答。</p>
</blockquote>
<blockquote>
<p>Sample Input</p>
</blockquote>
<blockquote>
<p>5 4</p>
</blockquote>
<blockquote>
<p>1 2 3 4 5</p>
</blockquote>
<blockquote>
<p>1 2 3 2</p>
</blockquote>
<blockquote>
<p>0 3 4</p>
</blockquote>
<blockquote>
<p>1 4 5 3</p>
</blockquote>
<blockquote>
<p>0 2 4</p>
</blockquote>
<blockquote>
<p>Sample Output</p>
</blockquote>
<blockquote>
<p>9</p>
</blockquote>
<blockquote>
<p>16</p>
</blockquote>
<p>手头没有一本书是讲线段树区间更新的，翻了无数博客，文档，而且网上所有资料里下标都是1开始的（很不习惯），终于写出了一个体现了C++面向对象风格的程序（其实就是把数据和操作封装了个对象-_-||）。</p>
<p>区间更新时并不是每个节点都更新，需要加一个标记，把要更新的数据放在标记里。等到需要修改子节点（比如更新或查询）的时候把这个标签里的信息传下去。如果你的查询或修改区间刚好和你二分处的区间相同，这个查询或修改操作就不再向下一层执行，而是直接返回结果。</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define __int64 long long
#define MAX 100005
class Node&#123;
public:
    int l,r;
    __int64 sum,add;
&#125;;
int num[MAX];

class SegTree&#123;
private:
    Node *tree;
    void PushDown(int id)&#123;
        int j=id*2+1;
        int mid=(tree[id].l+tree[id].r)/2;
        tree[j].add+=tree[id].add;
        tree[j+1].add+=tree[id].add;
        tree[j].sum+=tree[id].add*(mid-tree[id].l+1);
        tree[j+1].sum+=tree[id].add*(tree[id].r-mid);
        tree[id].add=0;
    &#125;
public:
    SegTree(int n)&#123;tree=new Node[4*n];&#125;
    ~SegTree()&#123;delete []tree;&#125;

    void Build(int l,int r,int id)&#123;
        tree[id].l=l; tree[id].r=r; tree[id].add=0;
        if(l==r)tree[id].sum=num[l];
        else&#123;
            int mid=(l+r)/2;
            Build(l,mid,id*2+1);
            Build(mid+1,r,id*2+2);
            tree[id].sum=tree[id*2+2].sum+tree[id*2+1].sum;
        &#125;
    &#125;;

    void Update(int l,int r,int c,int id)&#123;
        if (tree[id].l&gt;=l&amp;&amp;tree[id].r&lt;=r)&#123;
            tree[id].sum+=(__int64)c*(tree[id].r-tree[id].l+1);
            tree[id].add+=c;
        &#125;else&#123;
            if (tree[id].add) PushDown(id);
            int mid=(tree[id].l+tree[id].r)/2;
            int j=id*2+1;
            if (l&lt;=mid) Update(l,r,c,j);
            if (r&gt;mid) Update(l,r,c,j+1);
            tree[id].sum=tree[j].sum+tree[j+1].sum;
        &#125;
    &#125;;

    __int64 Query(int l,int r,int id)&#123;
        if (tree[id].l&gt;=l &amp;&amp; tree[id].r&lt;=r)
            return tree[id].sum;
        else&#123;
            if(tree[id].add) PushDown(id);
            int mid,j;
            __int64 ans=0;
            mid=(tree[id].l+tree[id].r)/2;
            j=id*2+1;
            if(l&lt;=mid) ans+=Query(l,r,j);
            if(r&gt;mid) ans+=Query(l,r,j+1);
            return ans;
        &#125;
    &#125;
&#125;;

int main()&#123;
    int n,m,a,b,c;
    int cmd;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,num+i);

    SegTree tt(n);

    tt.Build(0,n-1,0);
    while(m--)&#123;
        scanf(&quot;%d%d%d&quot;,&amp;cmd,&amp;a,&amp;b);
        if (cmd==1) scanf(&quot;%d&quot;,&amp;c);
        if (cmd==0)
            printf(&quot;%lld\n&quot;, tt.Query(a-1, b-1, 0));
        else
            tt.Update(a-1, b-1, c, 0);
    &#125;
    return 0;
&#125;</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Xposed AppSettings权限管理原理分析</title>
    <url>/2015/02/13/xposed-appsettings/</url>
    <content><![CDATA[<p>本文分析一个权限管理类Xposed模块的<a href="">源代码</a>，主要分析权限管理功能实现的原理。完全按照本人看代码的顺序写成。写此文主要不是为了分析代码，而是总结这种分析代码的思路。所以，懒得看过程可以直接跳到<a href="##分析代码">代码分析</a>。</p>
<h2 id="准备工作"># 准备工作</h2>
<p>下载好源代码，还要在手机上把这个程序安装好，这样能直观感受它的功能。</p>
<h2 id="大致思路"># 大致思路</h2>
<p>我们最关键的任务是找到权限控制的核心代码并弄明白它的功能。但是这么多的文件无从下手。我的想法是结合程序的实际操作，然后翻出来相应的代码。</p>
<h2 id="直奔主题">直奔主题</h2>
<p>先看AndroidManifest.xml，因为我们要找程序启动界面。除了xposed的meta data，有个定义launcher activity的代码：</p>
<pre><code>&lt;activity
    android:name=&quot;.XposedModActivity&quot;
    android:label=&quot;@string/app_name&quot;
    android:configChanges=&quot;orientation|screenSize&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;</code></pre>
<p>就是说类<code>de.robv.android.xposed.mods.appsettings.XposedModActivity</code>包含启动界面的代码。</p>
<p>在手机上打开程序，会看到启动界面主要是一个ListView，每项里面放着app的名称和包名。点击其中某项会跳到新的Activity里。那么目标明确了，找这个跳转代码。</p>
<p>我用startAcitivity为关键词找到了：</p>
<pre><code>list.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;

            @Override
            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;
                // Open settings activity when clicking on an application
                String pkgName = ((TextView) view.findViewById(R.id.app_package)).getText().toString();
                Intent i = new Intent(getApplicationContext(), ApplicationSettings.class);
                i.putExtra(&quot;package&quot;, pkgName);
                startActivityForResult(i, position);
            &#125;
&#125;);</code></pre>
<p>可见，ApplicationSettings这个类包含了新的Activity的代码。</p>
<p>新界面只有一个switch，打开switch后所有的选项都出来了。我手机的左下角出现了一个叫”权限管理“的按钮。点开以后是一个对话框，里面的ListView罗列了所有的应用权限让我们修改。单击List里的某项，权限就被禁用了,同时权限的字体由白变紫。</p>
<p>所以我先找这个按钮的代码:</p>
<pre><code>btnPermissions.setOnClickListener(new View.OnClickListener() &#123;
            @Override
            public void onClick(View v) &#123;
                // set up permissions editor
                try &#123;
                    final PermissionSettings permsDlg = new PermissionSettings(ApplicationSettings.this, pkgName, allowRevoking, disabledPermissions);
                        permsDlg.setOnOkListener(new PermissionSettings.OnDismissListener() &#123;
                        @Override
                        public void onDismiss(PermissionSettings obj) &#123;
                            allowRevoking = permsDlg.getRevokeActive();
                            disabledPermissions.clear();
                            disabledPermissions.addAll(permsDlg.getDisabledPermissions());
                        &#125;
                    &#125;);
                    permsDlg.display();
                &#125; catch (NameNotFoundException e) &#123;
                &#125;
            &#125;
&#125;);</code></pre>
<p>看来<code>PermissionSettings</code>就是权限管理界面的类。在这个类中唯一被我发现的和ListView有关的代码：</p>
<pre><code>// Load the list of permissions for the package and present them
    loadPermissionsList(pkgName);

    final PermissionsListAdapter appListAdapter = new PermissionsListAdapter(owner, permsList, disabledPerms, true);
    appListAdapter.setCanEdit(revokeActive);
    ((ListView) dialog.findViewById(R.id.lstPermissions)).setAdapter(appListAdapter);
    </code></pre>
<p>所以说处理单击ListView项并改变程序权限的代码应该在别的地方。</p>
<p>只能是在Adapter的代码里了：</p>
<pre><code>if (allowEdits) &#123;
    row.setOnClickListener(new View.OnClickListener() &#123;
        @Override
        public void onClick(View v) &#123;
            if (!canEdit) &#123;
                return;
            &#125;

            TextView tv = (TextView) v.findViewById(R.id.perm_name);
            if ((tv.getPaintFlags() &amp; Paint.STRIKE_THRU_TEXT_FLAG) != 0) &#123;
                disabledPerms.remove(tv.getTag());
                tv.setPaintFlags(tv.getPaintFlags() &amp; (~Paint.STRIKE_THRU_TEXT_FLAG));
                tv.setTextColor(Color.WHITE);
            &#125; else &#123;
                disabledPerms.add((String) tv.getTag());
                tv.setPaintFlags(tv.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);
                tv.setTextColor(Color.MAGENTA);
            &#125;
        &#125;
    &#125;);
&#125;</code></pre>
<p>在这里<code>disabledPerms</code>是一个<code>Set&lt;String&gt;</code>类型的对象。顾名思义，这里面方的可能是被禁用的权限。上面代码并没有直接处理权限的部分。结合Diaglog界面有“确定”按钮，推测最后程序先将权限添加到Set中，然后统一禁止权限。</p>
<p>那么<code>disabledPerms</code>怎么传递出去的呢？搜索整个Adapter的代码，看到构造函数里有一句：<code>this.disabledPerms = disabledPerms;</code>。再回头看该才找到的<code>PermissionSettings</code>类里和List唯一有关的代码里有：</p>
<pre><code>final PermissionsListAdapter appListAdapter = new PermissionsListAdapter(owner, permsList, disabledPerms, true);</code></pre>
<p>所以<code>disabledPerms</code>就是我们要找的。下一步可以找<code>PermissionSettings</code>里的这个<code>disabledPerms</code>里的结果怎么返回回去的。搜索这个类里的代码，找到了get方法：</p>
<pre><code>/**
* Get the list of permissions in the disabled state
 */
public Set&lt;String&gt; getDisabledPermissions() &#123;
    return new HashSet&lt;String&gt;(disabledPerms);
&#125;</code></pre>
<p>我们之前找到的<code>ApplicationSettings</code>里面的<code>btnPermissions.setOnClickListener</code>里有这么一行：<code>disabledPermissions.addAll(permsDlg.getDisabledPermissions());</code>。</p>
<p>另外<code>disabledPermissions</code>只有声明没有定义。在<code>onCreate()</code>方法里它才被赋值：</p>
<pre><code>// Setting for permissions revoking
allowRevoking = prefs.getBoolean(pkgName +   Common.PREF_REVOKEPERMS, false);
disabledPermissions = prefs.getStringSet(pkgName + Common.PREF_REVOKELIST, new HashSet&lt;String&gt;());</code></pre>
<p>同时在<code>private Map&lt;String, Object&gt; getSettings()</code>这个方法结尾处有这么两行：</p>
<pre><code>if (disabledPermissions.size() &gt; 0)
    settings.put(pkgName + Common.PREF_REVOKELIST, new HashSet&lt;String&gt;(disabledPermissions));
    </code></pre>
<p>方法的返回值就是settings。如果再看看整个方法的代码，可知这个应用的所有被修改内容全放到这个<code>settings</code>里了。</p>
<p>在<code>onOptionsItemSelected</code>里出现了<code>getSettings()</code>的调用，同时还有很多sharedPreference的操作。在手机上，我们修改应用权限，然后单击右上角的保存按钮，弹出提示对话框，询问是否结束进程以便下次启动时采用新设置。根据这点找到代码：</p>
<pre><code>prefsEditor.commit();

// Update saved settings to detect modifications later
initialSettings = newSettings;

// Check if in addition to saving the settings, the app should also be killed
AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setTitle(R.string.settings_apply_title);
builder.setMessage(R.string.settings_apply_detail);
builder.setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() &#123;
    @Override
    public void onClick(DialogInterface dialog, int which) &#123;
        // Send the broadcast requesting to kill the app
        Intent applyIntent = new Intent(Common.MY_PACKAGE_NAME + &quot;.UPDATE_PERMISSIONS&quot;);
        applyIntent.putExtra(&quot;action&quot;, Common.ACTION_PERMISSIONS);
        applyIntent.putExtra(&quot;Package&quot;, pkgName);
        applyIntent.putExtra(&quot;Kill&quot;, true);
        sendBroadcast(applyIntent, Common.MY_PACKAGE_NAME + &quot;.BROADCAST_PERMISSION&quot;);

        dialog.dismiss();
    &#125;
&#125;);</code></pre>
<p>整个工程只有一个PackagePermissions类是BroadcastReceiver类。打开后发现这个类有大量的Xposed的hook函数。那么问题来了：</p>
<ul>
<li>广播接受器什么时候开始工作的？</li>
<li>哪些是hook权限的操作？</li>
<li>hook是如何在开机时就开始了（否则没办法监控权限）</li>
</ul>
<p>在BroadcastReceiver里叫initHooks()的静态方法里找到：</p>
<pre><code>final Class&lt;?&gt; clsPMS = findClass(&quot;com.android.server.pm.PackageManagerService&quot;, XposedMod.class.getClassLoader());

// Listen for broadcasts from the Settings part of the mod, so it&#39;s applied immediately
findAndHookMethod(clsPMS, &quot;systemReady&quot;, new XC_MethodHook() &#123;
    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;
        Context mContext = (Context) getObjectField(param.thisObject, &quot;mContext&quot;);
        mContext.registerReceiver(new PackagePermissions(param.thisObject),
                new IntentFilter(Common.MY_PACKAGE_NAME + &quot;.UPDATE_PERMISSIONS&quot;),
                Common.MY_PACKAGE_NAME + &quot;.BROADCAST_PERMISSION&quot;,
                null);
    &#125;
&#125;);

// if the user has disabled certain permissions for an app, do as if the hadn&#39;t requested them
findAndHookMethod(clsPMS, &quot;grantPermissionsLPw&quot;, &quot;android.content.pm.PackageParser$Package&quot;, boolean.class,
        new XC_MethodHook() &#123;
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;
        String pkgName = (String) getObjectField(param.args[0], &quot;packageName&quot;);
        if (!XposedMod.isActive(pkgName) || !XposedMod.prefs.getBoolean(pkgName + Common.PREF_REVOKEPERMS, false))
            return;

        Set&lt;String&gt; disabledPermissions = XposedMod.prefs.getStringSet(pkgName + Common.PREF_REVOKELIST, null);
        if (disabledPermissions == null || disabledPermissions.isEmpty())
            return;

        ArrayList&lt;String&gt; origRequestedPermissions = (ArrayList&lt;String&gt;) getObjectField(param.args[0], &quot;requestedPermissions&quot;);
        param.setObjectExtra(&quot;orig_requested_permissions&quot;, origRequestedPermissions);

        ArrayList&lt;String&gt; newRequestedPermissions = new ArrayList&lt;String&gt;(origRequestedPermissions.size());
        for (String perm: origRequestedPermissions) &#123;
            if (!disabledPermissions.contains(perm))
                newRequestedPermissions.add(perm);
            else
                // you requested those internet permissions? I didn&#39;t read that, sorry
                Log.w(Common.TAG, &quot;Not granting permission &quot; + perm
                        + &quot; to package &quot; + pkgName
                        + &quot; because you think it should not have it&quot;);
        &#125;

        setObjectField(param.args[0], &quot;requestedPermissions&quot;, newRequestedPermissions);
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;
        // restore requested permissions if they were modified
        ArrayList&lt;String&gt; origRequestedPermissions = (ArrayList&lt;String&gt;) param.getObjectExtra(&quot;orig_requested_permissions&quot;);
        if (origRequestedPermissions != null)
            setObjectField(param.args[0], &quot;requestedPermissions&quot;, origRequestedPermissions);
    &#125;</code></pre>
<h2 id="分析代码">分析代码</h2>
<p>BroadcastReceiver里的注释说：</p>
<pre><code>/* Hook to the PackageManager service in order to
* - Listen for broadcasts to apply new settings and restart the app
* - Intercept the permission granting function to remove disabled permissions
*/</code></pre>
<p>也就是说监听器hook到了Android系统的包管理器类<code>com.android.server.pm.PackageManagerService</code>，并且hook了里面的方法。所以上面提到的哪些是hook权限的操作基本上解决了，代码之后详细分析。那么广播什么时候开始接收的？在IntelliJ里搜索BroadcastReceiver被用到的地方，发现：</p>
<ol type="1">
<li>XposedMod类中<code>initZygote</code>方法里出现<code>PackagePermissions.initHooks();</code></li>
<li>刚才贴出的大段BroadcastReceiver里出现<code>mContext.registerReceiver</code>里面有它的构造函数。</li>
</ol>
<p><code>initZygote</code>是Xposed框架<code>IXposedHookZygoteInit</code>接口中要自己实现的方法。接口的源代码为：</p>
<pre><code>/**
* Hook the initialization of Zygote (the central part of the &quot;Android OS&quot;)
*/
public interface IXposedHookZygoteInit extends IXposedMod &#123;
/**
 * Called very early during startup of Zygote
 * @throws Throwable everything is caught, but will prevent further initialization of the module
 */
    public void initZygote(StartupParam startupParam) throws Throwable;

    public static class StartupParam &#123;
        public String modulePath;
 &#125;
&#125;</code></pre>
<p>这就意味着每当启动一个进程，都会执行<code>initZygote</code>里监听器的<code>initHooks()</code>方法来给包管理器挂钩。权限监听的钩子应该挂到<code>com.android.server.pm.PackageManagerService</code>这个类的名为的<code>grantPermissionsLPw</code>方法上。程序用了Xposed框架提供的<code>findAndHookMethod</code>方法。通过这个方法接收的参数，我们得知被hook的<code>grantPermissionsLPw</code>方法接收两个参数，分别是Package类型（android.content.pm.PackageParser的内部类），和boolean。<code>initHooks()</code>方法还顺带注册监听器来接受来自appSettings这个app自己发出的广播。再进一步查看工程代码和安卓源代码，就知道，appSettings的权限拦截原理是这样的：</p>
<p>原来的权限授权以前先：从之前appsSettings存储的sharedPreferences里取得对应应用的权限列表，放到<code>Set&lt;String&gt; disabledPermissions</code>里。并用<code>ArrayList&lt;String&gt; origRequestedPermissions</code>存放应用索要的权限，并利用Xposed自带的方法存储一份这个权限列表到<code>param</code>对象里。然后通过for each循环，对比两个ArrayList，生成第三张表<code>newRequestedPermissions</code>,并用<code>setObjectField</code>方法替换掉了原来Package对象的<code>requestedPermissions</code>对象。</p>
<p>之后，安卓系统会按照被我们“调包”的权限清单执行程序。</p>
<p>被hook过的方法执行以后：从param对象取出我们刚刚保存的原始的权限列表，然后再次用<code>setObjectField</code>把这个原始列表复原回去。</p>
<p>于是第二个问题，哪些是hook操作，怎么hook的问题就解决了。</p>
<p>最后，我们打开工程目录下<code>assets/xposed_init</code>文件，看到<code>de.robv.android.xposed.mods.appsettings.XposedMod</code>。所以，Xposed框架开始执行的就是这个类里的代码。它实现了<code>IXposedHookZygoteInit</code>与 <code>IXposedHookLoadPackage</code>接口。所以能：1.在zygote启动时执行，从而管理权限。2.在应用app的包加载前执行hook操作，替换应用资源（这是appSettings另一个功能，但本文不分析）。</p>
<p>所以，为何启动时就能hook的问题也解决了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习总结2</title>
    <url>/2016/07/10/design-patterns-2/</url>
    <content><![CDATA[<h1 id="结构型模式">结构型模式</h1>
<p>这次主要说结构型模式。这类模式还是在各种场合比较常见的。</p>
<h2 id="适配器模式">适配器模式</h2>
<p>这个模式主要用来解决一些接口不相互兼容的情况。举个例子：现在有一类电器，都是插在110V的电压的电源上。然而电源现在只有220V的。为了让电器能够用上电，必须在220V电源和110V用电器之间弄一个转换器把电压转成110V。</p>
<p>在这里需要明确一下这个模式的几个参与者：</p>
<h3 id="参与者">参与者</h3>
<ul>
<li><strong>Client</strong>：使用者，与符合Target接口的对象协同工作。这个例子里就是用电器。</li>
<li><strong>Target</strong>：与Client使用的特定领域相关的接口。这里就是符合110V电压标准的那类电源插孔。</li>
<li><strong>Adaptee</strong>：已经存在的接口，它需要适配。这里就是220V电源。</li>
<li><strong>Adapter</strong>：适配器，对Adaptee的接口与Target的接口进行适配。这个例子里就是110V转换器。</li>
</ul>
<p>这里有个问题：为什么需要一个Target，直接用Adapter不可以么？回答：Client需要的是符合某个接口规范的一类类，而不是具体的某个类。Adapter是一定实现了Target的接口的。就像转换器可以有很多种类和品牌，有些甚至可以带一些无关的花哨的功能，但是一定都具有转换功能并提供一个符合要求的输出插孔。</p>
<p>这个设计模式有两种实现方法：</p>
<ul>
<li>使用多重继承，Adapter继承Target和Adaptee。</li>
<li>使用对象组合。Adapter仍然继承Target且拥有Adaptee对象实例。</li>
</ul>
<p>对于多重继承的方法，Adapter应该私有继承Adaptee（防止公有接口暴露）。</p>
<p>这个例子的代码写下来应该是这样的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowerSupport110</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Power110 <span class="title">getPower110</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;<span class="comment">//Target</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaPowerSupport220</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Power220 <span class="title">getPower220</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/*......*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//Adaptee</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdapter110</span>:</span><span class="keyword">public</span> PowerSupport110, <span class="keyword">private</span> ChinaPowerSupport220 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> Power110 <span class="title">getPower110</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> convert110(getPower220());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;<span class="comment">//Adapter</span></span><br></pre></td></tr></table></figure></p>
<h2 id="代理模式">代理模式</h2>
<p>这个模式为访问某个对象提供了控制手段。举2个例子：</p>
<ul>
<li>1.打开网页的时候某些大的图片、动画可能要过一段时间才能加载出来，但是网页提供了一个占位符，即使没加载出来，我们也可以查看图片的信息，控制重新加载内容，或者另存为到本地。</li>
<li>2.C++里的智能指针（比如shared_ptr）。</li>
</ul>
<h3 id="参与者-1">参与者</h3>
<p>这个模式的参与者有如下的几个（以第1个网站的例子说明）：</p>
<ul>
<li><strong>Subject</strong>：声明了RealSubject和Proxy的共同接口，这样任何使用RealSubject的地方都可以使用Proxy。这个例子中就是网页里的图片（准确说是图片的接口，因为操作都是针对接口的）。</li>
<li><strong>Proxy</strong>：内部含有RealSubject的引用，从而可以操作RealSubject对象；提供一个与Subject接口相同的接口，这样就可以替代实体；控制实体的存取，并可能负责创建和删除它。还有其它功能依赖于代理的类型。</li>
<li><strong>RealSubject</strong>：定义了Proxy代表的实体。</li>
</ul>
<h3 id="代理的类型">代理的类型：</h3>
<ul>
<li>1.远程代理：为一个对象在不同的地址空间提供局部代表。</li>
<li>2.虚代理：根据需求创建开销很大的对象。（占位符的例子）</li>
<li>3.保护代理：控制对原始对象的访问（比如希望它们有不同的访问权限）。</li>
<li>4.智能指引：在访问对象的同时执行一些附加的操作（如：C++的shared_ptr）。</li>
</ul>
<p>以图片加载的例子为例的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> imgName;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graphic(<span class="keyword">const</span> <span class="keyword">char</span>* s):imgName(s)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span>:</span> <span class="keyword">public</span> Graphic&#123;</span><br><span class="line">    Image *img;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">LoadFromDisk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;imgName;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; loaded!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        img = <span class="keyword">new</span> Image;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Picture(<span class="keyword">const</span> <span class="keyword">char</span>* s):Graphic(s)&#123;</span><br><span class="line">        LoadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Displaying &quot;</span>&lt;&lt;imgName&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PicProxy</span>:</span> <span class="keyword">public</span> Graphic&#123;</span><br><span class="line">    Picture *pic;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PicProxy(<span class="keyword">const</span> <span class="keyword">char</span>* s):Graphic(s)&#123;</span><br><span class="line">        pic = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pic==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pic = <span class="keyword">new</span> Picture(imgName.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        pic-&gt;display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">PicProxy <span class="title">pp</span><span class="params">(<span class="string">&quot;pic1.jpg&quot;</span>)</span></span>;</span><br><span class="line">    pp.display();</span><br><span class="line">    pp.display();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰器模式">装饰器模式</h2>
<p>有时候我们希望动态的给<strong>对象</strong>添加职责（不是整个类，而是某个对象），就可以用这个模式。</p>
<p>整个模式中的参与者：</p>
<ul>
<li><strong>Component</strong>：定义了一个对象接口，可以给这些对象动态添加职责。它是抽象的。</li>
<li><strong>ConcreteComponent</strong>：定义了对象，可以给这些对象动态添加职责。它继承自Component。可以给这个对象添加职责。</li>
<li><strong>Decorator</strong>：维持一个指向Component对象的指针，且定义了与Component接口一致的接口。</li>
<li><strong>ConcreteDecorator</strong>：维持一个指向Component对象的指针，且定义了与Component接口一致的接口。</li>
</ul>
<h3 id="应用举例">应用举例</h3>
<p>比较典型的装饰器的用法是Java里各种I/O流。比如：InputStream这个抽象类是Component。FileInputStream是ConcreteComponent，它实现了InputStream的read接口，然而它除了简单的read一些东西外，并没有什么高级功能。</p>
<p>如果希望扩展出高级功能就需要Decorator。Java中比较典型的是FilterInputStream（相当于Decorator）。它的子类：BufferedInputStream、DataInputStream就是ConcreteDecorator。这两个ConcreteDecorator的构造函数的参数都是InputStream类型。</p>
<p>BufferedInputStream是带缓冲的，DataInputStream的作用是从流中读出不同的Java数据类型。那么，如果用BufferedInputStream修饰FilterInputStream，再用DataInputStream修饰刚才的BufferedInputStream，就可以从带缓冲的文件流中读各种Java数据类型。 即： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataInputStream inputstream = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;Data.txt&quot;</span>)));</span><br></pre></td></tr></table></figure></p>
<p>下面是一份Java代码， 代码中View对象被滚动条修饰后又被边框Border修饰： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vbill;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">VisualComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">VisualComponent</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing view!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">VisualComponent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> VisualComponent comp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(VisualComponent comp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comp = comp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        comp.Draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Border</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Border</span><span class="params">(VisualComponent comp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(comp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.Draw();</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing border!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollBar</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScrollBar</span><span class="params">(VisualComponent comp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(comp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.Draw();</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing scrollbar!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Border b = <span class="keyword">new</span> Border(<span class="keyword">new</span> ScrollBar(<span class="keyword">new</span> View()));</span><br><span class="line">        b.Draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="外观模式">外观模式</h2>
<p>如果现在有一个很复杂的系统（编译器之类的），但是用户不关心这个复杂系统的内部各个子系统的工作细节，那么可以引入一个Facade类，由它提供我们关心的部分，并负责将我们的请求代理给合适的子系统对象（比如我们要编译程序，编译器的lexer, parser等等部件我们不关心，我们只要一系列编译指令和能设置的参数选项）。</p>
<p>举个例子：现在有个工厂，某客户要进货。工厂有3个部门分别负责订单处理，生产，出货。</p>
<p>在没有外观模式之前可能是这样的（以下是Java代码）： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码写在客户代码里</span></span><br><span class="line"><span class="comment">// 依次创建三个部门实例</span></span><br><span class="line">Order order = <span class="keyword">new</span> Order();</span><br><span class="line">Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">Sender sender = <span class="keyword">new</span> Sender();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次调用三个部门实例的方法</span></span><br><span class="line">order.order(<span class="number">1000</span>);  <span class="comment">//订1000件</span></span><br><span class="line">Goods goods = producer.produce(order);</span><br><span class="line">sender.send(goods);</span><br></pre></td></tr></table></figure></p>
<p>使用外观模式： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">       <span class="comment">//定义被封装的三个部门</span></span><br><span class="line">       Order order；</span><br><span class="line">       Producer producer;</span><br><span class="line">       Sender sender;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.order = <span class="keyword">new</span> Order();</span><br><span class="line">       <span class="keyword">this</span>.producer = <span class="keyword">new</span> producer();</span><br><span class="line">       <span class="keyword">this</span>.sender = <span class="keyword">new</span> Sender();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Goods <span class="title">buyThings</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//把整个流程封装</span></span><br><span class="line">       order.order(num);  <span class="comment">//订num件</span></span><br><span class="line">       Goods goods = producer.produce(order);</span><br><span class="line">       sender.send(goods);</span><br><span class="line">       <span class="keyword">return</span> goods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以使用了： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Factory f = <span class="keyword">new</span> Factory();</span><br><span class="line">Goods g  = f.buyThings(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="桥接模式">桥接模式</h2>
<p>这个模式可以实现抽象与实现分离，使得它们可以各自独立变化。</p>
<p>举例：现在有一个Window类，它提供了基本的绘图功能（绘制文字，矩形）。其它各种具体的Window里的绘图功能都是基于Window里这些基本操作实现的。现在我们希望Window类跨平台，或者运行时修改基本绘图功能的实现。如果使用继承机制，那么必须位每个平台或实现继承出一个类。因为继承是静态的，所以每增加一个平台Window的每种子类都要继承出一个对应平台的类，这是很麻烦的。</p>
<p>改进的方法是：把平台相关的部分操作独立出来。因为这些操作接口相同，因此可以独立成一个抽象类（比如叫WindowImp，它包含绘制文字、矩形的接口）。那么这些独立出来的每种平台的具体实现就继承自这个独立出的抽象类。然后在原来的Window类里维护一个抽象类的指针。原来用到的平台相关的操作，现在都通过指针指向的对象来实现。当需要改变这部分实现的时候，只让这个指针指向其它版本的实现就可以了。</p>
<h3 id="模式的参与者">模式的参与者</h3>
<ul>
<li><strong>Abstraction</strong>：抽象部分的接口。维护一个Implementor的对象指针。</li>
<li><strong>RefinedAbstraction</strong>：扩展Abstraction的接口。</li>
<li><strong>Implementor</strong>：定义实现类的接口，该接口不用和Abstraction的完全一致；事实上它们可以完全不同。一般Implementor接口提供基本操作，而Abstraction里定义了基于这些基本操作的较高层次的操作。</li>
<li><strong>ConcreteImplementor</strong>：真正实现Implementor接口的对象。</li>
</ul>
<p>这个模式之所以叫”桥接“，就是因为Abstraction和Implementor（本例中的WindowImp是Implementor，Abstraction是Window）起到了桥梁作用，将各个平台具体的实现ConcreteImplementor和RefinedAbstraction（各类具体的Window）联系了起来。</p>
<p>下面是例子的Java代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vbill;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WindowImp</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DevDrawText</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DevDrawLine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinuxWindowImp</span> <span class="keyword">implements</span> <span class="title">WindowImp</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DevDrawText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing text on linux&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DevDrawLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing line on linux&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsWindowImp</span> <span class="keyword">implements</span> <span class="title">WindowImp</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DevDrawText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing text on Windows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DevDrawLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing line on Windows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>&#123;<span class="comment">//声明为abstract 防止实例化</span></span><br><span class="line">    <span class="keyword">private</span> WindowImp imp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">DrawText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        imp.DevDrawText();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">DrawRect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        imp.DevDrawLine();</span><br><span class="line">        imp.DevDrawLine();</span><br><span class="line">        imp.DevDrawLine();</span><br><span class="line">        imp.DevDrawLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;Rect ok!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Window</span><span class="params">()</span></span>&#123;imp = <span class="keyword">new</span> WindowsWindowImp();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeAPI</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(imp <span class="keyword">instanceof</span> WindowsWindowImp)&#123;</span><br><span class="line">            imp = <span class="keyword">new</span> LinuxWindowImp();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            imp = <span class="keyword">new</span> WindowsWindowImp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigWindow</span> <span class="keyword">extends</span> <span class="title">Window</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawBigWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Big window ok!&quot;</span>);</span><br><span class="line">        DrawRect();</span><br><span class="line">        DrawText();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallWindow</span> <span class="keyword">extends</span> <span class="title">Window</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawSmallWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Small window ok!&quot;</span>);</span><br><span class="line">        DrawRect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigWindow b = <span class="keyword">new</span> BigWindow();</span><br><span class="line">        b.DrawBigWindow();</span><br><span class="line">        b.ChangeAPI();</span><br><span class="line">        b.DrawBigWindow();</span><br><span class="line"></span><br><span class="line">        SmallWindow s = <span class="keyword">new</span> SmallWindow();</span><br><span class="line">        s.DrawSmallWindow();</span><br><span class="line">        s.ChangeAPI();</span><br><span class="line">        s.DrawSmallWindow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="组合模式">组合模式</h2>
<p>将对象组合成树形结构以表示”整体-部分“的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>举个最简单的例子：做PPT的时候，Powerpoint提供了许多基本图形。我们可以画几个基本图形，然后点击”组合“。这样就行成了组合图形。而且软件对新的组合图形还有基本图形的操作基本是一样的。这种方式在其它许多绘图软件里也很常见。</p>
<p>这个模式的关键在于提供了一个抽象类。基本的图形类继承自它，图形的组合容器类也继承自它。这样用户操纵抽象类的时候，基本图形和容器看上去就是一样的。</p>
<p>这样看上取，对象的组合关系就像一棵树一样，是递归的。</p>
<h3 id="模式的参与者-1">模式的参与者</h3>
<ul>
<li><p><strong>Component</strong></p>
<p>--为组合中的对象声明接口。</p>
<p>--在适当情况下实现所有类共有接口的缺省行为。</p>
<p>--声明一个接口，用于访问和管理Component的子组件</p>
<p>--（可选）在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它。</p>
<p>在上面例子中，把图形抽象成Graphic类，就是Component。</p></li>
<li><p><strong>Leaf</strong></p>
<p>--在组合中表示叶节点对象。叶节点没有子节点</p>
<p>显然基本的图形就是Leaf。</p></li>
<li><p><strong>Composite</strong></p>
<p>--定义有子部件的那些部件的行为。</p>
<p>--存储子部件。</p>
<p>--在Component接口中实现与子部件有关的操作。</p>
<p>显然容器类就是Composite。它可以存放多个基本图形和容器的组合。本例中可以命名它为Pic。</p></li>
<li><p><strong>Client</strong></p>
<p>--通过Component的接口操纵组合部件。</p></li>
</ul>
<p>这里有个问题：模式中所有的类均继承自Component。但是Component提供了许多对Leaf而言不必要的接口，比如添加/删除组合部件，返回孩子部件的代码。解决这个问题的方法是，在Component中提供默认的操作（什么都不做，返回无效值，抛出异常等等），然后在Leaf型的对象中不要重写这些无关的方法，在用到这些接口方法的Composite类型中重写这些方法。</p>
<p>下面是例子的Java代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vbill;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PicComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(PicComponent p)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(PicComponent p)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function">PicComponent <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">PicComponent</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span> <span class="keyword">extends</span> <span class="title">PicComponent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Text&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">PicComponent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Triangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span> <span class="keyword">extends</span> <span class="title">PicComponent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;PicComponent&gt; comps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Picture</span><span class="params">()</span></span>&#123;</span><br><span class="line">        comps = <span class="keyword">new</span> LinkedList&lt;PicComponent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(PicComponent p : comps)&#123;</span><br><span class="line">            p.show();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(PicComponent p)</span> </span>&#123;</span><br><span class="line">        comps.add(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(PicComponent p)</span> </span>&#123;</span><br><span class="line">        comps.remove(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PicComponent <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> comps.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Picture bigpic = <span class="keyword">new</span> Picture();</span><br><span class="line"></span><br><span class="line">        Text txt = <span class="keyword">new</span> Text();</span><br><span class="line">        Triangle tri = <span class="keyword">new</span> Triangle();</span><br><span class="line">        Rectangle rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        Picture smallpic = <span class="keyword">new</span> Picture();</span><br><span class="line">        smallpic.add(txt);</span><br><span class="line">        smallpic.add(tri);</span><br><span class="line">        smallpic.add(rect);</span><br><span class="line"></span><br><span class="line">        Rectangle rect2 = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line">        bigpic.add(rect2);</span><br><span class="line">        bigpic.add(smallpic);</span><br><span class="line"></span><br><span class="line">        bigpic.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="享元模式">享元模式</h2>
<p>该模式运用共享技术，支持大量细粒度对象。</p>
<p>比如：现在需要开发一个文本编辑器。其中文本框内每个字符都有自己的字形、位置等等信息。如果为每个字符都创建一个对象实例，那么内存空间的开销将会非常巨大。</p>
<p>实际上在创建对象的时候有写信息是可以共享的。比如，文字可能是ASCII字符集里的。那么每个对象就不必维护自己的字形，只需要记录自己的位置就可以了。</p>
<p>到这里就涉及2个概念：</p>
<ul>
<li><strong>外部状态</strong>：会随着不同的场景变化，这些信息不能被共享。</li>
<li><strong>内部状态</strong>：独立于具体场景的信息，这些信息使得flyweight可以被共享。</li>
</ul>
<p>那么，这个例子里字形就是内部状态，位置就是外部状态。</p>
<h3 id="模式的参与者-2">模式的参与者</h3>
<ul>
<li><p><strong>Flyweight</strong>：</p>
<p>--描述一个接口，通过它flyweight可以接受并作用于外部状态。</p></li>
<li><p><strong>ConcreteFlyweight</strong>： --实现Flyweight接口，并为内部状态（如果有）增加存储空间。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的（独立于ConcreteFlyweight）对象的场景。</p></li>
<li><p><strong>UnsharedConcreteFlyweight</strong>：</p>
<p>--Flyweight接口使得共享成为可能，但是也可以有一些对象不被共享。比如：在文本编辑器里，多个字符可以组成一个行对象。这样ConcreteFlyweight对象（字符）就是UnsharedConcreteFlyweight的子节点。</p></li>
<li><p><strong>FlyweightFactory</strong>：</p>
<p>--创建并管理Flyweight对象。当用户请求一个Flyweight的时候，它提供一个已经创建的实例，或创建一个（如果不存在的话）。</p></li>
<li><p><strong>Client</strong>：</p>
<p>--维持对Flyweight的引用，计算/存储多个Flyweight的外部状态。</p></li>
</ul>
<p>如果外部状态是算出来的而不是存储起来的，空间节约将达到最大。比如：字符在屏幕中的位置是根据窗口尺寸和它是第几个字符算出来的。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习总结3</title>
    <url>/2016/07/11/design-patterns-3/</url>
    <content><![CDATA[<h1 id="行为模式">行为模式</h1>
<p>这次总结行为模式。行为模式主要涉及算法涉及对象的职责分配问题。</p>
<h2 id="迭代器模式">迭代器模式</h2>
<p>先介绍这个模式是因为它太常见了。各种编程语言的容器都有自己的迭代器。比如：Java中的List是个接口。只要符合List接口的各种List都可以使用它的迭代器来按照某种顺序遍历访问List的元素，而不必关心具体List的实现（是ArrayList还是LinkedList之类的）。</p>
<p>迭代器模式的主要用来：</p>
<ul>
<li><p>访问一个聚合对象的内容而不必暴露它的内部表示。</p></li>
<li><p>支持聚合对象的各种遍历。</p></li>
<li><p>为遍历不同的聚合结构提供一个统一的接口（多态迭代）。</p></li>
</ul>
<h3 id="参与者">参与者</h3>
<ul>
<li><p><strong>Iterator</strong></p>
<p>--迭代器定义访问和遍历元素的接口。在Java中List的iterator()方法返回一个实现了Iterator接口的迭代器。这是典型的Iterator。</p></li>
<li><p><strong>ConcreteIterator</strong></p>
<p>--具体的迭代器实现了Iterator接口。并能在遍历容器时跟踪当前位置。</p></li>
<li><p><strong>Aggregate</strong></p>
<p>--定义创建响应迭代器对象的接口。也就是它可以返回Iterator。比如：Java的List。</p></li>
<li><p><strong>ConcreteAggregate</strong></p>
<p>--实现了创建响应迭代器对象的接口，返回迭代器实例。</p></li>
</ul>
<p>推荐看Java中LinkedList的代码。</p>
<h2 id="职责链模式">职责链模式</h2>
<p>这个模式用来避免请求的发送者和接受者之间的耦合关系。如果有多个对象，它们都有机会处理请求（但是何时处理的条件不同），就可以把对象连成一条链，沿着该链传递请求，知道有一个对象处理它为止。</p>
<p>举例：我们看龙珠或者其它战斗类型的漫画的时候会发现一个问题：主角去挑战大Boss的时候总是先打小Boss，再打大Boss，也就是说小Boss挂了或搞不定的时候大 Boss才会亲自动手。这就形成了一个责任链！可以把主角的挑战看成是请求，职责链上的对象（各种Boss）负责处理请求。如果职责链上的对象发现自己无法处理请求（小Boss打不过挂掉了），这个请求就会转发到下一对象（更高级的Boss），否则就处理这个请求（就是Boss赢了）。可以把打的过程看成是判断是否可以处理请求，输赢看成转发和处理。</p>
<p>这里需要注意，职责链上的对象在转发请求的时候是不知道最终会由谁处理请求的（小Boss打输后不是很确定后面的Boss会不会赢）。</p>
<h3 id="上面这个例子的参与者">上面这个例子的参与者</h3>
<ul>
<li><p><strong>Handler(Boss 类)</strong></p>
<p>--定义一个处理请求的接口。在这里可以抽象出一个Boss类。 --（可选）实现后继链。</p></li>
<li><p><strong>ConcreteHandler(Boss类的子类，各种Boss)</strong></p>
<p>--处理它负责的请求。</p>
<p>--可以访问后继者。</p>
<p>--如果能处理请求就处理，否则转发请求给后继者。</p></li>
<li><p><strong>Client(主角)</strong></p>
<p>--向链上的具体处理者ConcreteHandler提交请求。</p></li>
</ul>
<p>例子的代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kakarotto</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boss</span>&#123;</span><span class="comment">//handler</span></span><br><span class="line">    Boss *successor;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> power;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Boss(<span class="keyword">int</span> p, Boss *s):power(p), successor(s)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleChallenge</span><span class="params">(Kakarotto *k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(successor==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Challenger win!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        successor-&gt;handleChallenge(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kakarotto</span>&#123;</span><span class="comment">//client</span></span><br><span class="line">    <span class="keyword">int</span> power;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Kakarotto(<span class="keyword">int</span> p):power(p)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Challenge</span><span class="params">(Boss *b)</span></span>&#123;</span><br><span class="line">	    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Challenging&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	    b-&gt;handleChallenge(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPower</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> power;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vegeta</span>:</span> <span class="keyword">public</span> Boss&#123;<span class="comment">//concrete handler 1</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vegeta(<span class="keyword">int</span> p, Boss *s):Boss(p, s)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleChallenge</span><span class="params">(Kakarotto* k)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Vegeta is challenged!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(k-&gt;getPower()&lt;power)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Vegeta win!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Vegeta failed&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            Boss::handleChallenge(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Freeze</span>:</span> <span class="keyword">public</span> Boss&#123;<span class="comment">//concrete handler 2 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Freeze(<span class="keyword">int</span> p, Boss *s):Boss(p, s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleChallenge</span><span class="params">(Kakarotto* k)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Freeze is challenged!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(k-&gt;getPower()&lt;power)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Freeze win!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Freeze failed&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            Boss::handleChallenge(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Kakarotto * k = <span class="keyword">new</span> Kakarotto(<span class="number">10000</span>);</span><br><span class="line">    Freeze *f = <span class="keyword">new</span> Freeze(<span class="number">1000000</span>, <span class="literal">NULL</span>);</span><br><span class="line">    Vegeta *v = <span class="keyword">new</span> Vegeta(<span class="number">5000</span>, f);</span><br><span class="line">    k-&gt;Challenge(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="命令模式">命令模式</h2>
<p>将请求封装为对象，可用不同的请求对客户进行参数化。用于“行为请求者”与“行为实现者”解耦。</p>
<p>举例：</p>
<p>现在有一个文档处理程序中用到了菜单。菜单中有许多菜单项。每个菜单项执行一个或一系列命令。程序用某种UI框架开发。显然，框架开发者是不知道菜单具体会执行哪些功能的，它只知道何时执行（即用户触发了Click事件它可以捕捉到，然后去执行具体功能）。具体的命令，将被封装成对象，以供调用。</p>
<p>在这个例子中，要执行的命令都实现了Command接口中的方法。菜单项MenuItem就是负则调用Command接口中方法的类，从而在用户点击菜单项时执行操作（准确说操作是Command类的子类里的接受者Receiver执行的）。应用程序类为App，它持有具体的命令对象（Command的子类）并绑定了接受者，建立了MenuItem具体Item类的联系。Receiver是文档类Document，它知道如何如何对文档实施具体的操作。</p>
<h3 id="上面这个例子的参与者-1">上面这个例子的参与者</h3>
<ul>
<li><p><strong>Command</strong></p>
<p>--声明操作的接口</p></li>
<li><p><strong>ConcreteCommand(复制、粘贴等等)</strong></p>
<p>--将一个接受者对象绑定于一个动作。</p>
<p>--调用接受者相应的操作，从而实现execute()。</p></li>
<li><p><strong>Client(App)</strong></p>
<p>--创建具体命令对象并设置接受者。</p></li>
<li><p><strong>Invoker(菜单项MenuItem)</strong></p>
<p>--要求该命令执行这个请求。注意一个Invoker可以对应多个Command。</p></li>
<li><p><strong>Receiver(Document)</strong></p>
<p>--知道如何实施与执行一个请求相关的操作。</p></li>
</ul>
<p>这里有个疑问：为什么需要Command类，而不是直接使用Invoker？这是因为Command类的execute()方法中可以做点别的工作，比如记录指令日志，从而支持撤销命令等等。</p>
<p>命令模式和过程式语言的回调函数机制十分类似。</p>
<p>下面是一个例子代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vbill;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doc</span></span>&#123;<span class="comment">//receiver</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Doc</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;edit &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;open &quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;<span class="comment">//command</span></span><br><span class="line">    <span class="keyword">protected</span> Doc doc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(Doc doc)</span></span>&#123; <span class="keyword">this</span>.doc = doc; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditCommmand</span> <span class="keyword">extends</span> <span class="title">Command</span></span>&#123;<span class="comment">//concrete command</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EditCommmand</span><span class="params">(Doc doc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(doc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        doc.edit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenCommmand</span> <span class="keyword">extends</span> <span class="title">Command</span></span>&#123;<span class="comment">//concrete command</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenCommmand</span><span class="params">(Doc doc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(doc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        doc.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//invoker</span></span><br><span class="line">    <span class="keyword">private</span> Command com;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting for invoke!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        com.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCom</span><span class="params">(Command com)</span></span>&#123; <span class="keyword">this</span>.com = com; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//client</span></span><br><span class="line">        Command coms[] = <span class="keyword">new</span> Command[]&#123; <span class="keyword">new</span> OpenCommmand(<span class="keyword">new</span> Doc(<span class="string">&quot;1.txt&quot;</span>)),</span><br><span class="line">                                        <span class="keyword">new</span> EditCommmand(<span class="keyword">new</span> Doc(<span class="string">&quot;1.txt&quot;</span>))&#125;;</span><br><span class="line">        Invoker inv = <span class="keyword">new</span> Invoker();</span><br><span class="line">        <span class="keyword">for</span>(Command com : coms) &#123;</span><br><span class="line">            inv.setCom(com);</span><br><span class="line">            inv.run();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inv.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="策略模式">策略模式</h2>
<p>定义了一系列的算法的封装，使得它们可以相互替换。这使得算法可以独立于使用它的客户而变化。</p>
<p>显然，因为算法之间是可以替换的，所以它们有相同的接口，我们管这个接口叫做策略（Strategy）。</p>
<p>举个例子：现在有一个程序提供了一个搜索条，根据文本的长短和各个字符出现的频率，它可以调整自己的字符串搜索算法。</p>
<h3 id="以上例子中的参与者">以上例子中的参与者</h3>
<ul>
<li><p><strong>Strategy</strong></p>
<p>--定义了所有算法的公共接口。Context使用这个接口来调用ConcreteStrategy定义的算法。上面这个例子中，可以定义一个只含1个方法的接口，它接收2个参数，一个是正文的指针，另一个是待搜索串的指针。</p></li>
<li><p><strong>ConcreteStrategy</strong></p>
<p>--以Strategy接口实现的算法。在这个例子中就是各种字符串搜索算法。</p></li>
<li><p><strong>Context</strong></p>
<p>--上下文。用1个ConcreteStrategy对象来配置。维护一个ConcreteStrategy对象的引用。并且可定义一个接口让Strategy访问它的数据。</p></li>
</ul>
<p>下面是一个配置了不同的字符串搜索算法的策略模式的例子： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vbill;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StrfindStrategy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strFind</span><span class="params">(String dest, String pattern)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMPFinder</span> <span class="keyword">implements</span> <span class="title">StrfindStrategy</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calcNext</span><span class="params">(String pattern)</span></span>&#123;</span><br><span class="line">        next = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j = -<span class="number">1</span>; i&lt;pattern.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; pattern.charAt(j+<span class="number">1</span>) != pattern.charAt(i))</span><br><span class="line">                j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(pattern.charAt(j+<span class="number">1</span>) == pattern.charAt(i)) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strFind</span><span class="params">(String dest, String pattern)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pattern.length()&gt;dest.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        calcNext(pattern);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=-<span class="number">1</span>; i&lt;dest.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; pattern.charAt(j+<span class="number">1</span>)!=dest.charAt(i))</span><br><span class="line">                j = next[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pattern.charAt(j+<span class="number">1</span>)==dest.charAt(i)) j++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j==pattern.length()-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i-pattern.length()+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultFinder</span> <span class="keyword">implements</span> <span class="title">StrfindStrategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strFind</span><span class="params">(String dest, String pattern)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dest.indexOf(pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StrfindStrategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(StrfindStrategy s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">execute</span><span class="params">(String dest, String pattern)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.strFind(dest, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(StrfindStrategy s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//client</span></span><br><span class="line">        String dest = <span class="string">&quot;xbaadabcabab&quot;</span>;</span><br><span class="line">        String pattern = <span class="string">&quot;abab&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Context con = <span class="keyword">new</span> Context(<span class="keyword">new</span> DefaultFinder());</span><br><span class="line">        System.out.println(con.execute(dest, pattern));</span><br><span class="line">        con.setStrategy(<span class="keyword">new</span> KMPFinder());</span><br><span class="line">        System.out.println(con.execute(dest, pattern));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="观察者模式">观察者模式</h2>
<p>定义对象间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p>
<p>举个例子：现在有许多个统计图（柱状图、折现图、扇形图），这些图都反映了同一个表格的数据，如果表格中的数据改变了，图中的内容也要自动发生响应的变化。</p>
<h3 id="模式的参与者">模式的参与者</h3>
<ul>
<li><p><strong>Subject</strong></p>
<p>--目标知道它的观察者，可以有多个观察者观察同一个目标。</p>
<p>--提供注册和删除观察者的接口。</p></li>
<li><p><strong>Observer</strong></p>
<p>--为那些在目标发生改变时需要获得通知的对象定义一个更新接口。</p></li>
<li><p><strong>ConcreteSubject</strong></p>
<p>--将有关状态存入各ConcreteObserver对象。</p>
<p>--当它的状态发生改变时，向它的各个观察者发出通知。</p></li>
<li><p><strong>ConcreteObserver</strong></p>
<p>--维护一个指向ConcreteSubject对象的引用</p>
<p>--存储有关状态，这些状态应与目标的状态保持一致。</p>
<p>--实现Observer的更新接口以使自身状态与目标的状态保持一致。</p></li>
</ul>
<p>在Java语言中自带了该模式相关的接口，下面是例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vbill;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span></span>&#123;</span><br><span class="line">    <span class="comment">//concrete subject</span></span><br><span class="line">    <span class="comment">//Observable is subject</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = i;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="comment">//concrete observer</span></span><br><span class="line">    <span class="comment">//Observer is observer</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        MyObservable myObservable = (MyObservable) o;</span><br><span class="line">        System.out.println(<span class="string">&quot;Data changed to &quot;</span>+ myObservable.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//client</span></span><br><span class="line">        MyObservable d = <span class="keyword">new</span> MyObservable();</span><br><span class="line">        d.addObserver(<span class="keyword">new</span> MyObserver());</span><br><span class="line">        d.addObserver(<span class="keyword">new</span> MyObserver());</span><br><span class="line">        d.setData(<span class="number">12</span>);</span><br><span class="line">        d.setData(<span class="number">1</span>);</span><br><span class="line">        d.setData(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在jdk源代码里，Observable接口(相当于Subject)是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>jdk中Observer接口的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="备忘录模式">备忘录模式</h2>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样就可以将该对象恢复到原先保存的状态。</p>
<p>在这个模式中一个备忘录就是一个用来记录状态的对象，它记录的是某个对象在某个时刻的状态。被记录的对象称为Originator。当需要进行记录的时候，Originator请求一个备忘录，并用自己的当前状态设置备忘录对象。只有Originator能够存取备忘录的信息，其它对象则不可以。</p>
<h3 id="参与该模式的参与者">参与该模式的参与者</h3>
<ul>
<li><p><strong>Memento</strong></p>
<p>--备忘录存储原发器对象的内部状态。原发器根据需要决定存储哪些内部状态。</p>
<p>--防止原发器外的其它对象访问备忘录。备忘录实际有2个接口，一个是Caretaker看到的窄接口，它只能将备忘录传递给其它对象。原发器只能看到宽接口，允许它访问返回到先前状态所需要的数据。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的状态。</p></li>
<li><p><strong>Originator</strong></p>
<p>--原发器创建一个备忘录记录当前自己的状态。</p>
<p>--使用备忘录恢复内部状态。</p></li>
<li><p><strong>Caretaker</strong></p>
<p>--负责保存备忘录</p>
<p>--不能对备忘录的内容进行检查操作或检查。</p></li>
</ul>
<p>下面是一份Java代码的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vbill;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MementoNarrow</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span> <span class="keyword">implements</span> <span class="title">MementoNarrow</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">        setState(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;MementoNarrow&gt; list = <span class="keyword">new</span> LinkedList&lt;MementoNarrow&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        list.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Memento)list.getLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        list.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//client</span></span><br><span class="line">        Originator org = <span class="keyword">new</span> Originator();</span><br><span class="line">        CareTaker ct = <span class="keyword">new</span> CareTaker();</span><br><span class="line"></span><br><span class="line">        org.setState(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        ct.add(org.createMemento());</span><br><span class="line"></span><br><span class="line">        org.setState(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        ct.add(org.createMemento());</span><br><span class="line"></span><br><span class="line">        org.setState(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(org.getState());</span><br><span class="line"></span><br><span class="line">        org.getStateFromMemento(ct.get());</span><br><span class="line">        ct.remove();</span><br><span class="line">        System.out.println(org.getState());</span><br><span class="line"></span><br><span class="line">        org.getStateFromMemento(ct.get());</span><br><span class="line">        ct.remove();</span><br><span class="line">        System.out.println(org.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态模式">状态模式</h2>
<p>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p>也就是说这个对象的行为随着状态改变！</p>
<p>举个例子：现在有个2状态状态机，状态分别叫0和1。状态机只有2个输入0和1。在0状态下输入0状态始终为0，在0状态下输入1会切换到1。在1状态下输入1状态始终为1，输入0则切换到0状态。并且你有1个LED灯，当状态为1时灯亮，否则灯灭。</p>
<h3 id="参与者-1">参与者</h3>
<ul>
<li><p><strong>Context</strong></p>
<p>--定义用户感兴趣的接口。</p></li>
<li><p><strong>State</strong></p>
<p>--定义一个接口以封装与Context的一个特定状态相关的行为。</p></li>
<li><p><strong>ConcreteState</strong></p>
<p>--每一个子类实现一个与Context的一个状态相关的行为。</p></li>
</ul>
<p>需要注意的是这个模式和<strong>策略模式</strong>非常<strong>相似</strong>。如果画出UML类图，会发现两者几乎是一样的。那么问题来了，究竟它们有啥区别？</p>
<p>在状态模式中，Context或ConcreteState子类都可以决定哪个状态是另外一个的后继者，以及是在何种条件下进行状态转换。</p>
<p>在策略模式中，Context将它的客户的请求转发给它的Strategy。客户通常创建并传递一个ConcreteStrategy对象给该Context；这样客户仅与Context交互。通常有一系列的ConcreteStrategy类可供客户从中选择。</p>
<p>上面的状态机的例子的Java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vbill;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LED</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State0</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LED</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> i = scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            context.setState(<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            context.setState(<span class="keyword">new</span> State1());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unknown state&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State1</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LED</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> i = scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            context.setState(<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            context.setState(<span class="keyword">new</span> State0());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unknown state&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(State state)</span></span>&#123;</span><br><span class="line">        setState(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLED</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            state.LED(<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context con = <span class="keyword">new</span> Context(<span class="keyword">new</span> State0());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">while</span>(i--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            con.requestLED();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中介者模式">中介者模式</h2>
<p>用一个中介对象来封装一些列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其松散耦合，而且可以独立地改变它们之间的交互。</p>
<p>举例：现在有个对话框，上面有很多部件。比如：有文本框、列表框、一个确定按钮，仅当文本框里有内容时，按钮才能按下，按下按钮后文本框的内容将会被发送给程序的后台处理。在用户懒得输入文本框内容时，可以从列表框里选择几个预置的内容填入文本框。</p>
<p>如果直接让各个对象之间进行通信，耦合度是很高的。如果把各种集体行为封装在一个中介者(mediator)中就可以避免这个问题。中介者用来协调一组对象的交互，它使得对象之间不再显式的相互调用，这些对象只知道中介者。中介者就是对象通信的中转中心。</p>
<h3 id="参与者-2">参与者</h3>
<ul>
<li><p><strong>Mediator</strong></p>
<p>--中介者定义一个接口用于与各个同事对象通信。</p></li>
<li><p><strong>ConcreteMediator</strong></p>
<p>--具体中介者通过协调各个同事对象实现协作行为。</p>
<p>--了解并维护它的各个同事。</p></li>
<li><p><strong>Colleague Class</strong></p>
<p>--每个同事类都知道它的中介者对象。</p>
<p>--每一个同事对象在需要与其它同事通信的时候都与它的中介者通信。</p></li>
</ul>
<p>上面提到的例子的Java代码如下（不含测试类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DialogDirector director;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        director.WidgetChanged(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Widget</span><span class="params">(DialogDirector dialogDirector)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.director = dialogDirector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DialogDirector</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WidgetChanged</span><span class="params">(Widget w)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListBox</span> <span class="keyword">extends</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> chosen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);  list.add(<span class="string">&quot;2&quot;</span>);  list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListBox</span><span class="params">(DialogDirector dialogDirector)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dialogDirector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChosen</span><span class="params">(<span class="keyword">int</span> chosen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chosen = chosen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChosenElement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(chosen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextField</span> <span class="keyword">extends</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        changed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextField</span><span class="params">(DialogDirector dialogDirector)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dialogDirector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> avail = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getAvail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.avail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAvail</span><span class="params">(<span class="keyword">boolean</span> avail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.avail = avail;</span><br><span class="line">        changed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(DialogDirector dialogDirector)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dialogDirector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDialogDirector</span> <span class="keyword">implements</span> <span class="title">DialogDirector</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button okButton = <span class="keyword">new</span> Button(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> ListBox listBox = <span class="keyword">new</span> ListBox(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> TextField textField = <span class="keyword">new</span> TextField(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WidgetChanged</span><span class="params">(Widget w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w.equals(okButton))&#123;</span><br><span class="line">            <span class="keyword">if</span>(okButton.getAvail()==<span class="keyword">false</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;Not available!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span> + textField.getContent());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(w.equals(textField))&#123;</span><br><span class="line">            okButton.setAvail(!textField.getContent().equals(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            textField.setContent(listBox.getChosenElement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问者模式">访问者模式</h2>
<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。</p>
<p>举例：<a href="http://www.runoob.com/design-pattern/visitor-pattern.html">这里</a>有一个完整的例子。</p>
<h3 id="模式的参与者-1">模式的参与者</h3>
<ul>
<li><p><strong>Visitor</strong></p>
<p>--为该对象结构中的ConcreteElement的每一个类声明一个visit操作。该操作的名字和特征标示了发送visit请求给该访问者的那个类。这使得访问者可以确定被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。</p></li>
<li><p><strong>ConcreteVisitor</strong></p>
<p>--实现每个由Visitor声明的操作。每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中基类结果。</p></li>
<li><p><strong>Element</strong></p>
<p>--定义一个Accept操作，它以一个访问者为参数。</p></li>
<li><p><strong>ConcreteElement</strong></p>
<p>--实现Accept操作，该操作以一个访问者为参数。</p></li>
<li><p><strong>ObjectStructure</strong></p>
<p>--能枚举它的元素。</p>
<p>--可以提供一个高层的接口以允许该访问者访问它的元素。‘</p>
<p>--可以是一个符合（Composite）或是一个集合，如一个列表或一个无序集合。</p></li>
</ul>
<h2 id="解释器模式">解释器模式</h2>
<p>给定一个语言，定义它的文法表示，并定义一个解释器，将这个解释器使用该表示来解释语言中的句子。</p>
<p>这个模式应用的情景比较特殊（个人感觉），比如：HTML解释器，正则表达式等等，甚至解释型语言的解释器。</p>
<h3 id="模式参与者">模式参与者</h3>
<ul>
<li><p><strong>AbstractExpression</strong></p>
<p>--声明一个抽象的解释操作，这个接口为抽象语法树中所有节点所共享。</p></li>
<li><p><strong>TerminalExpression</strong></p>
<p>--实现与文法中的终结符相关的解释操作。</p>
<p>--一个句子中的每个终结符需要该类的一个实例。</p></li>
<li><p><strong>NonterminalExpression</strong></p>
<p>--对文法中的每一条文法规则<code>R::R1R2...Rn</code>都需要一个NonterminalExpression类。</p>
<p>--为从R1到到Rn的每个符号都维护一个AbstractExpression类型的实例变量。</p>
<p>--为文法中的非终结符实现解释操作。解释一般要递归地调用表示R1到Rn的那些对象的解释操作。</p></li>
<li><p><strong>Context</strong></p>
<p>--包含解释器之外的一些全局信息。</p></li>
<li><p><strong>Client</strong></p>
<p>--构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树。该抽象语法树由NonterminalExpression和TerminalExpreession的实例装配而成。</p>
<p>--调用解释操作。</p></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>（译）Xposed模块开发教程</title>
    <url>/2015/02/10/xposed-1/</url>
    <content><![CDATA[<p><a href="https://github.com/rovo89/XposedBridge/wiki/Development-tutorial">原文地址</a>。这是开发者所写的，可以说是官方开发指南。文章讲述了Xposed的原理，以及怎么开发Xposed框架的模块。头一次翻译技术文档，有错误的话请多包涵。</p>
<p>好了，你想学习怎么为Xposed开发新的模块么？那么读读这篇教程（或者我们可以称他为”泛读短文”）学着怎么去做。这不仅包括“创建这个文件然后插入…”这类的技巧，也包括这些技巧背后的思想。这些思想正是创造价值的步骤以及你真正需要了解你做了什么和为什么这么做的原因。如果你觉得本文“太长，不想读”，那么你可以只看最后的源代码和阅读“<a href="#使工程成为Xposed模块">使工程成为Xposed模块</a>“部分。但是如果你读了整篇文章你就会有更好的理解。你之后会节省出来阅读这个的时间，因为你不必凭自己弄清楚每件事。</p>
<h2 id="修改主题"># 修改主题</h2>
<p>你将重新创建在<a href="https://github.com/rovo89/XposedExamples/tree/master/RedClock">github</a>上可以找到的红色钟表的的例子。它包括将状态栏的钟表变为红色并且加入一个笑脸的功能。我选择这个例子是因为它非常小，而且容易看见所做的修改。并且，它也使用了框架所提供的一些基本方法。</p>
<h2 id="xposed如何工作"># Xposed如何工作</h2>
<p>在你开始做出自己的修改之前，你应当大致了解Xposed如何工作（如果觉得这部分无聊可以跳过）。以下就是原理：</p>
<p>有一个叫做”Zygote”的进程，它是android运行环境的核心。每个应用都从一份它的拷贝(“fork”)产生。这个进程在手机启动时由一个叫 /init.rc 的脚本启动。这个进程的启动在 /system/bin/app_process 加载所需要的类和调用初始化方法后完成。</p>
<p>这里就是Xposed发挥用处的地方了。当你安装完框架后，<a href="https://github.com/rovo89/Xposed">一个扩展过的app_process</a>就会被复制到 /system/bin 下。这个扩展过的启动进程会将一个额外的jar包添加到环境变量，并在特定场合调用里面的方法。比如：当虚拟机创建完成后和Zygote的main方法被调用前。并且在那个方法当中，我们已经是Zygote的一部分，而且能够在它的上下文context中活动。</p>
<p>jar包的位置是 /data/data/de.robv.android.xposed.installer/bin/XposedBridge.jar 它的源代码可以在<a href="https://github.com/rovo89/XposedBridge">这里</a>找到。查看<a href="https://github.com/rovo89/XposedBridge/blob/master/src/de/robv/android/xposed/XposedBridge.java">XposedBridge</a>的类，你能找到main方法。这就是我上文中所写过的，它在每个进程的最开始部分被调用。一些初始化的工作在那里完成，并且我们的模块在那里加载（之后我再讲模块的加载）。</p>
<h2 id="方法的hook替换"># 方法的hook/替换</h2>
<p>真正使Xpoesed有威力的就是hook方法调用。当你反编译并修改APK时，你能够在任何你想的地方直接修改/替换指令。然而，你事后需要重新编译/给APK签名，并且只能发布整个安装包。使用Xposed能让你放置的hook，你并不能修改程序内部的方法代码(清楚地定义你想要在何处做什么样的修改是不可能的)。然而，你可以在方法调用的前后注入你的代码。这也是java中能够被清楚寻址的最小单位。</p>
<p>XposedBridge 有一个私有的 native 方法叫做 hookMethodNative。这个方法也在扩展后的 app_process 中被实现了。它会将方法类型转为“native”，并把方法的实现与本地的通用方法相连。这意味着，每当被hook的方法调用后，调用者不知道实际调用的是通用的方法。在这个方法中，位于 XposedBridge 的 handleHookedMethod 方法会被调用，并向方法调用传递参数、this指针以及其他东西。之后这个方法负责唤起之前方法调用注册过的回调。上述这些行为能够改变调用的参数、实例/静态变量、唤起其他方法、处理调用结果。。。或者跳过这些东西。它的弹性非常大。</p>
<p>好了，理论讲够了。我们现在创建一个模块吧！</p>
<h2 id="创建工程"># 创建工程</h2>
<p>一个模块就是一个普通的app，只不过多了一些特殊的文件和元数据。所以在我们创建新的android工程以前，我假设你已经做过这个了。如果没有，<a href="http://developer.android.com/sdk/installing.html">官方文档</a>讲的很详细。对于SDK，我选择了4.0.3（API15）。我建议你也使用这个，并且不要立刻开始。你不需要创建Activity，因为我们的修改不需要任何用户界面。回答过了这个问题后，你应该有一个空白的工程项目。</p>
<h2 id="使工程成为xposed模块"># 使工程成为Xposed模块</h2>
<p>现在我们把工程变成Xposed能加载的东西。我们需要以下几个步骤。</p>
<h2 id="androidmanifest.xml">AndroidManifest.xml</h2>
<p>Xposed Installer的模块列表搜寻所有有一种特殊元数据标记的应用程序。你可以到 AndroidManifest.xml =&gt; Application =&gt; Application Nodes (在底部) =&gt; Add =&gt; Meta Data 下面去创建这个标记。标记名称应该是 xposedmodule ，值应该是 true。给resource留空。重复以上过程创建 xposedminversion (见下文) 和 xposeddescription (你创建的模块的简单描述)。XML文件现在就是这个样子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
 &lt;manifest  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;de.robv.android.xposed.mods.tutorial&quot;
    android:versionCode=&quot;1&quot;
    android:versionName=&quot;1.0&quot; &gt;

    &lt;uses-sdk android:minSdkVersion=&quot;15&quot; /&gt;

    &lt;application
        android:icon=&quot;@drawable/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot; &gt;
        &lt;meta-data
            android:name=&quot;xposedmodule&quot;
            android:value=&quot;true&quot; /&gt;
        &lt;meta-data
            android:name=&quot;xposeddescription&quot;
            android:value=&quot;Easy example which makes the status bar clock red and adds a smiley&quot; /&gt;
        &lt;meta-data
            android:name=&quot;xposedminversion&quot;
            android:value=&quot;30&quot; /&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</code></pre>
<h2 id="xposedbridgeapi.jar">XposedBridgeApi.jar</h2>
<p>接下来，让程序能够找到 XposedBridge 的API。你可以从 <a href="http://forum.xda-developers.com/xposed/xposed-api-changelog-t2714067">这里</a>下载 <code>XposedBridgeApi-&lt;version&gt;.jar</code> 的最新版。把它复制到叫做lib的子文件夹下。右键单击选择Build Path =&gt; Add to Build Path。文件名当中的<code>&lt;version&gt;</code>是你在manifest文件的xposedminversion标签所插入的版本。</p>
<blockquote>
<p>保证API类没有被包含（但仅仅是参考）在你编译过的APK里，否则你会得到一个IllegalAccessError错误。libs（含有s）文件夹是eclipse自动生成的，不要把API文件放在那里。</p>
</blockquote>
<h2 id="模块的实现">模块的实现</h2>
<p>现在你可以给你的模块创建一个类了。我的类叫做”Tutorial”，位于de.robv.android.xposed.mods.tutorial这个包中。</p>
<pre><code>package de.robv.android.xposed.mods.tutorial;

public class Tutorial &#123;

&#125;</code></pre>
<p>第一步，我们仅仅生成一些日志表明模块已经加载。一个模块可以有多个入口点。你选择哪个取决于你想修改什么。你可以在安卓系统启动时、在一个app将要启动时、在一个app的资源文件初始化时或其他时候，调用一个函数。</p>
<p>在这个教程靠后面的一部分，你将了解到在一个特定的app中需要做出的修改。那么先让我们了解一下 “让我知道什么时候加载一个新app” 这个入口点。所有入口点都被标记为IXposedMod的子接口。这种情况下，你需要实现 IXposedHookLoadPackage 这个接口。其实它只有一个仅有一个参数的方法。这个方法向被实现的模块提供更多关于运行环境上下文的信息。在我们的例子中，我们用log输出加载的app的名称。</p>
<pre><code>package de.robv.android.xposed.mods.tutorial;

import de.robv.android.xposed.IXposedHookLoadPackage;
import de.robv.android.xposed.XposedBridge;
import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;

public class Tutorial implements IXposedHookLoadPackage &#123;
    public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable &#123;
        XposedBridge.log(&quot;Loaded app: &quot; + lpparam.packageName);
    &#125;
&#125;</code></pre>
<p>这个log方法向标准logcat以及 /data/data/de.robv.android.xposed.installer/log/debug.log（通过Xposed Installer可以轻易访问到）输出信息（tag Xposed）。</p>
<h2 id="assetsxposed_init">assets/xposed_init</h2>
<p>现在唯一遗漏的就是提示XposedBridge哪些类包含了入口点。这项工作通过一个叫 xposed_init 的文件完成。在assets文件夹下创建一个新的名叫xposed_init的text文件。在该文件中每行包含一个类的全名。在这个例子中，它是 de.robv.android.xposed.mods.tutorial.Tutorial。</p>
<h2 id="试试看"># 试试看</h2>
<p>保存你的文件。以Android Application的方式运行你的程序。因为这是你第一次安装它，在使用前你需要先启用。打开Xposed Installer这个app并确保你安装了xposed框架。之后切换到Modules标签。你应该能在那里找到你的app。在选择框内打钩使得它可用。然后重启。你当然什么变化也看不到，但如果检查log记录，以应该会看见以下的东西：</p>
<pre><code>Loading Xposed (for Zygote)...
Loading modules from   /data/app/de.robv.android.xposed.mods.tutorial-1.apk
Loading class de.robv.android.xposed.mods.tutorial.Tutorial
Loaded app: com.android.systemui
Loaded app: com.android.settings
... (many more apps follow)</code></pre>
<p>瞧！它起作用了。现在你拥有了一个Xposed模块。它能够变得比写一些log更加有用…</p>
<h2 id="探索你的目标并寻找修改它的方式"># 探索你的目标并寻找修改它的方式</h2>
<p>好了，下面要开始讲的部分也许会非常不同，这取决于你想做什么。如果你之前修改过apk，也许你会知道在这里应当如何思考。总的来说，你需要了解目标的一些实现细节。在本教程中，目标选定为状态栏的时钟。这有助于了解到状态栏以及其他一些东西都是系统UI的一部分。现在让我们在那里开始我们的探索。</p>
<p>可能性1：反汇编。这会告诉你它实际的实现，但是会很难阅读和理解，因为你得到的都是smali格式的东西。可能性2：获得AOSP源代码。比如<a href="http://source.android.com/source/downloading.html">这里</a>，<a href="http://grepcode.com/snapshot/repository.grepcode.com/java/ext/com.google.android/android/4.0.3_r1/">这里</a>。ROM不同代码也很不一样，但在本例中他们的实现是相似的甚至是相同的。我会先看AOSP，然后看看这么做够不够。如果我需要细节，我会看看实际的反汇编的代码。</p>
<p>你可以找找名称中有“clock”的类。其他需要找的是用到的资源和布局。如果你下载官方的AOSP代码，你可以从 frameworks/base/packages/SystemUI 开始找。你会找到好几处“clock”出现的地方。找到有好几种方式实现修改是正常而且真实的。时刻记住你“只能” hook方法。所以你必须另找其他能够插入代码实现功能的地方，要么在方法的前面或是后面，或者是替换掉方法。你应当hook一个尽可能明确的方法，而不是一个被调用成千上万次的用于解决性能问题和非计划中的副作用的方法。</p>
<p>在本例当中，你或许会发现布局 res/layout/status_bar.xml 包含一个指向带有类com.android.systemui.statusbar.policy.Clock的自定义view。现在你脑子里也许会有好多点子。文字的颜色是通过textAppearance属性定义的，所以最干净的更改它的方法就是修改外观的定义。然而，用Xposed框架改变外观属性几乎是不可能的（这需要深入本地代码）。替换状态栏的布局也许是可能的，但对于你试图做出的小小修改来说是杀鸡用牛刀。取而代之的是，看看这个类。有一个叫updateLock的方法，似乎每分钟都调用一次用于更新时间。</p>
<pre><code>final void updateClock() &#123;
    mCalendar.setTimeInMillis(System.currentTimeMillis());
    setText(getSmallTime());
&#125;</code></pre>
<p>这个方法用于修改来说是很好的，因为这是一个足够具体的看似唯一能够修改时钟文字的方法。如果我们在这个方法的每次调用之后都加些修改时钟文字和颜色的东西，应该就能起作用。那么，我们开始做吧。</p>
<blockquote>
<p>对于单独修改字体颜色部分，有一种更好的办法。参见“<a href="https://github.com/rovo89/XposedBridge/wiki/Replacing-resources">替换资源</a>”中“修改布局”的例子。</p>
</blockquote>
<h2 id="使用反射寻找并hook方法"># 使用反射寻找并hook方法</h2>
<p>现在我们已经知道了哪些东西？我们在com.android.systemui.statusbar.policy.Clock有一个叫做updateClock的希望干涉的方法。我们在系统UI资源中找到了这个类，所以它仅仅在系统UI进程当中有效。其它一些类属于框架，而且在任何地方都有效。如果我们在 handleLoadPackage 中试图直接获取任何这个类的信息和引用，就会失败。因为处于错误的进程中。所以让我们实现一种仅在某个特定包即将加载时执行特定代码的情况：</p>
<pre><code>public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable &#123;
    if (!lpparam.packageName.equals(&quot;com.android.systemui&quot;))
        return;

    XposedBridge.log(&quot;we are in SystemUI!&quot;);
&#125;</code></pre>
<p>使用参数，我们能轻松检查是否在正确的包中。一旦我们核实了这一点，我们就通过ClassLoader取得那个包中的也被这个变量引用的类。现在我们可以寻找com.android.systemui.statusbar.policy.Clock这个类以及它的updateClock方法，然后告诉XposedBridge去hook这个方法：</p>
<pre><code>package de.robv.android.xposed.mods.tutorial;

import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;
import de.robv.android.xposed.IXposedHookLoadPackage;
import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;

public class Tutorial implements IXposedHookLoadPackage &#123;
    public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable &#123;
        if (!lpparam.packageName.equals(&quot;com.android.systemui&quot;))
            return;

        findAndHookMethod(&quot;com.android.systemui.statusbar.policy.Clock&quot;, lpparam.classLoader, &quot;updateClock&quot;, new XC_MethodHook() &#123;
                @Override
                protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;
                // this will be called before the clock was updated by the original method
            &#125;
            @Override
            protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;
                // this will be called after the clock was updated by the original method
            &#125;
    &#125;);
    &#125;
&#125;</code></pre>
<p>findAndHookMethod是一个<a href="https://github.com/rovo89/XposedBridge/wiki/Helpers">Helper</a>函数。注意静态导入，如果你像连接中说的一样做了，那就会被自动加入。这个方法使用系统UI包的ClassLoader寻找 Clock 这个类，然后寻找其中的updateClock方法。如果这个方法中有任何参数，你必须事后列出这些参数的类型。有许多方法做这件事，但因为我们的方法没有参数，所以就先跳过这个步骤。至于最后一点，你需要提供一个 XC_MethodHook 类的实现。对于更小的更改，你可以使用匿名类。如果你的代码很多，最好创建普通的类并且只在这里创建实例。helper之后会如之前所说的，做出所有hook这个方法的必要工作。</p>
<p>XC_MethodHook中有两个你可以重写的方法。你可以两个都重写，或者都不重写。但后者的做法显然是没有道理的。这些方法就是beforeHookedMethod 和 afterHookedMethod。不难猜出他们在原有方法之前/后执行。你可以使用“before”方法在方法调用前估计/操纵参数（通过param.args）。甚至阻止调用原来的方法（发送你自己的结果）。“after”方法可以用来做一些基于原来方法的结果的事。你也可以在这个地方操纵结果。当然，你可以在方法调用的前/后添加你自己要执行的代码。</p>
<blockquote>
<p>如果你要彻底替换一个方法，去看看子类XC_MethodReplacement。在那里，你只需要重写replaceHookedMethod。</p>
</blockquote>
<p>XposedBridge为每个hook过的方法维护一个注册过的回调的表。拥有最高优先级（在hookMethod中被定义）的将被优先调用。原有的方法总是具有最低的优先级。所以如果你hook了一个拥有回调A（高优先级）和回调B（默认优先级）的方法，那么不管被hook的方法是如何被调用的，执行顺序总是这样的：A.before -&gt; B.before -&gt; original method -&gt; B.after -&gt; A.after。所以A可以影响B看到的参数，即把它们传递下去以前大幅度地修改它们。原有的方法的结果会先被B处理，但是A拥有原先调用者最终将得到什么样结果的决定权。</p>
<h2 id="最终步骤在方法调用之前后执行你自己的代码">最终步骤：在方法调用之前/后执行你自己的代码</h2>
<p>好了，你已经在正确的上下文运行环境中（比如：系统UI进程）有了一个在updateClock方法每次被调用时都会被调用的方法。现在让我们修改一些东西吧。</p>
<p>第一个要检查的：我们有具体的Clock类型的引用么？是的，我们有。这就是param.thisObject参数。所以如果方法通过myClock.updateClock()被调用，那么param.thisObject 就是 myClock。</p>
<p>接下来：我们对clock做什么？Clock类型并不可用，你不能将param.thisObject转换为类（也不要试着这样做）。然而它是从TextView继承而来。所以一旦你把Clock的引用转换为TextView，你可以使用像setText, getText 和 setTextColor之类的方法。我们的改动应该在原有的方法设置了新的时间以后进行。因为在方法被调用前什么都没有做，我们可以空着beforeHookedMethod。没有必要调用（空的）“super”方法。</p>
<p>所以以下是完整的源代码：</p>
<pre><code>package de.robv.android.xposed.mods.tutorial;

import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;
import android.graphics.Color;
import android.widget.TextView;
import de.robv.android.xposed.IXposedHookLoadPackage;
import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;

public class Tutorial implements IXposedHookLoadPackage &#123;
    public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable &#123;
        if (!lpparam.packageName.equals(&quot;com.android.systemui&quot;))
            return;

        findAndHookMethod(&quot;com.android.systemui.statusbar.policy.Clock&quot;, lpparam.classLoader, &quot;updateClock&quot;, new XC_MethodHook() &#123;
            @Override
            protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;
                TextView tv = (TextView) param.thisObject;
                String text = tv.getText().toString();
                tv.setText(text + &quot; :)&quot;);
                tv.setTextColor(Color.RED);
            &#125;
        &#125;);
    &#125;
&#125;</code></pre>
<h2 id="对结果感到满意"># 对结果感到满意</h2>
<p>现在启动/安装你的app。因为你第一次启动它时已经在Xposed Installer中把它设置为了可用，你就不需要在做这一步了。重启即可。然而，如果你正在使用这个红色钟表的例子，你也许想禁用它。两者都对它们的updateClock 处理程序使用了默认的优先级。所以你不清楚哪个会胜出（实际上这依赖于处理方法的字符串表示形式，但不要依赖这个方式）。</p>
<h2 id="结论"># 结论</h2>
<p>我知道这个教程很长。但我希望你现在不但能实现一个绿色的表，也能够做出一些完全不同的东西。找到好的被hook的方法是经验的问题，所以先从简单的做起。试着一开始多使用log函数确保每次调用都是你预期的。现在：祝玩得开心!</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
